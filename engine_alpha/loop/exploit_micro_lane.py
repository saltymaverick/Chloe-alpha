"""
Exploit Micro Lane (Phase 5c)
------------------------------

PAPER-only exploit execution lane with fund-grade constraints.

This lane:
  - Only opens trades when all gates pass (exploit gate, capital mode, ready_now)
  - Enforces strict concurrency (max 1 position total)
  - Uses micro sizing (max 50 USD notional)
  - Respects cooldown periods
  - Only trades symbols with lane_intent="exploit" and weight >= 0.15

Safety:
  - PAPER-only (hard guard)
  - Restrictive-only (never enables trading)
  - No config mutation (writes reports/logs only)
"""

from __future__ import annotations

import json
import os
import traceback
from dataclasses import dataclass, asdict
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Dict, Any, Optional, List

from engine_alpha.core.paths import REPORTS
from engine_alpha.risk.exploit_lane_gate import apply_exploit_lane_gate, is_ready_now
from engine_alpha.loop.position_manager import get_open_position, count_open_positions
from engine_alpha.loop.execute_trade import open_if_allowed
from engine_alpha.data.live_prices import get_live_ohlcv
from engine_alpha.signals.signal_processor import get_signal_vector
from engine_alpha.core.confidence_engine import decide

# Constants
MICRO_MAX_POSITIONS_TOTAL = 1
MICRO_MAX_NOTIONAL_USD = 50.0
MICRO_MAX_LEVERAGE = 1.0
MICRO_COOLDOWN_SECONDS = 3600  # 1 hour
MICRO_MIN_WEIGHT = 0.15
MICRO_REQUIRE_READY_NOW = True
MICRO_REQUIRE_CAPITAL_MODE_NORMAL = True

# Paths
CAPITAL_PLAN_PATH = REPORTS / "risk" / "capital_plan.json"
CAPITAL_PROTECTION_PATH = REPORTS / "risk" / "capital_protection.json"
LIVE_CANDIDATES_PATH = REPORTS / "risk" / "live_candidates.json"
CAPITAL_MOMENTUM_PATH = REPORTS / "risk" / "capital_momentum.json"
LOG_PATH = REPORTS / "loop" / "exploit_micro_log.jsonl"
STATE_PATH = REPORTS / "loop" / "exploit_micro_state.json"
ERROR_LOG_PATH = REPORTS / "loop" / "exploit_micro_errors.jsonl"

IS_PAPER_MODE = os.getenv("MODE", "PAPER").upper() == "PAPER"


@dataclass
class MicroLaneEvent:
    """Exploit micro lane event."""
    ts: str
    symbol: str
    action: str  # "would_open", "opened", "blocked", "skipped"
    reason: str
    weight: Optional[float] = None
    mode: Optional[str] = None
    ready_now: Optional[str] = None
    policy_level: Optional[str] = None
    notional: Optional[float] = None
    direction: Optional[int] = None
    confidence: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


def _load_json(path: Path) -> Dict[str, Any]:
    """Safely load JSON file."""
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def _save_json(path: Path, data: Dict[str, Any]) -> None:
    """Safely save JSON file."""
    path.parent.mkdir(parents=True, exist_ok=True)
    try:
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    except Exception:
        pass


def _append_log(event: MicroLaneEvent) -> None:
    """Append event to log file."""
    LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
    try:
        with LOG_PATH.open("a", encoding="utf-8") as f:
            f.write(json.dumps(event.to_dict()) + "\n")
    except Exception:
        pass


def _append_error_log(error_data: Dict[str, Any]) -> None:
    """Append full error details to error log file."""
    ERROR_LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
    try:
        with ERROR_LOG_PATH.open("a", encoding="utf-8") as f:
            f.write(json.dumps(error_data) + "\n")
    except Exception:
        pass


def _load_state() -> Dict[str, Any]:
    """Load micro lane state."""
    return _load_json(STATE_PATH)


def _save_state(state: Dict[str, Any]) -> None:
    """Save micro lane state."""
    _save_json(STATE_PATH, state)


def _check_cooldown(state: Dict[str, Any]) -> bool:
    """Check if cooldown period has passed."""
    cooldown_until = state.get("cooldown_until")
    if not cooldown_until:
        return True
    
    try:
        cooldown_ts = datetime.fromisoformat(cooldown_until.replace("Z", "+00:00"))
        now = datetime.now(timezone.utc)
        return now >= cooldown_ts
    except Exception:
        return True


def _set_cooldown(state: Dict[str, Any]) -> None:
    """Set cooldown timestamp."""
    now = datetime.now(timezone.utc)
    cooldown_until = now + timedelta(seconds=MICRO_COOLDOWN_SECONDS)
    state["cooldown_until"] = cooldown_until.isoformat()
    _save_state(state)


def _get_best_eligible_symbol(
    capital_plan: Dict[str, Any],
    capital_protection: Dict[str, Any],
    live_candidates: Dict[str, Any],
    capital_momentum: Dict[str, Any],
) -> Optional[tuple[str, Dict[str, Any]]]:
    """
    Select the single best eligible symbol for exploit micro lane.
    
    Returns:
        (symbol, symbol_data) tuple or None if no eligible symbol
    """
    # Check capital mode (handle different structures)
    capital_mode = capital_protection.get("mode")
    if not capital_mode:
        global_data = capital_protection.get("global", {})
        capital_mode = global_data.get("mode", "unknown")
    
    if MICRO_REQUIRE_CAPITAL_MODE_NORMAL and capital_mode != "normal":
        return None
    
    # Get symbols from capital plan
    by_symbol = capital_plan.get("by_symbol", {})
    if not by_symbol:
        return None
    
    # Filter eligible symbols
    eligible = []
    for symbol, plan_data in by_symbol.items():
        lane_intent = plan_data.get("lane_intent", "")
        weight = plan_data.get("weight", 0.0)
        
        # Check lane intent and weight
        if lane_intent != "exploit" or weight < MICRO_MIN_WEIGHT:
            continue
        
        # Check live candidate readiness
        live_cand = live_candidates.get("by_symbol", {}).get(symbol, {})
        ready_now_val = live_cand.get("ready_now")
        if MICRO_REQUIRE_READY_NOW and not is_ready_now(ready_now_val):
            continue
        
        # Check exploit gate (in-memory evaluation)
        try:
            can_open, gate_decision = apply_exploit_lane_gate(
                symbol=symbol,
                can_open=True,
                is_paper=IS_PAPER_MODE,
                is_exploration=False,
            )
            if not can_open:
                continue
        except Exception:
            continue
        
        # Get momentum data (optional filter)
        momentum_data = capital_momentum.get("by_symbol", {}).get(symbol, {})
        churn_tag = momentum_data.get("churn_tag", "stable")
        
        eligible.append({
            "symbol": symbol,
            "weight": weight,
            "plan_data": plan_data,
            "live_cand": live_cand,
            "momentum": momentum_data,
            "churn_tag": churn_tag,
        })
    
    if not eligible:
        return None
    
    # Sort by weight (descending) and select top
    eligible.sort(key=lambda x: x["weight"], reverse=True)
    best = eligible[0]
    
    return (best["symbol"], best)


def _compute_notional(weight: float) -> float:
    """Compute notional size based on weight."""
    # Base notional = weight * 250, capped at MICRO_MAX_NOTIONAL_USD
    base_notional = weight * 250.0
    return min(base_notional, MICRO_MAX_NOTIONAL_USD)


def run_once(reason: str = "scheduled") -> Dict[str, Any]:
    """
    Run exploit micro lane evaluation once.
    
    This is now a thin wrapper around exploit_lane_runner (single source of truth).
    
    Returns:
        Dict with decision and result
    """
    if not IS_PAPER_MODE:
        return {
            "action": "skipped",
            "reason": "not_paper_mode",
            "ts": datetime.now(timezone.utc).isoformat(),
        }
    
    # Delegate to exploit_lane_runner (single source of truth)
    try:
        from engine_alpha.loop.exploit_lane_runner import run_exploit_lane
        result = run_exploit_lane()
        
        # Convert result format for compatibility
        actions = result.get("actions", [])
        if actions:
            # Return first action (opened/closed/blocked)
            first_action = actions[0]
            return {
                "action": first_action.get("action", "blocked"),
                "reason": first_action.get("reason", ""),
                "symbol": first_action.get("symbol"),
                "ts": datetime.now(timezone.utc).isoformat(),
            }
        else:
            return {
                "action": "blocked",
                "reason": "no_actions",
                "ts": datetime.now(timezone.utc).isoformat(),
            }
    except Exception as e:
        # Log full error details with traceback
        ts = datetime.now(timezone.utc).isoformat()
        error_str = str(e)
        error_repr = repr(e)
        error_traceback = traceback.format_exc()
        
        # Log to error log with full details
        error_data = {
            "ts": ts,
            "error_type": type(e).__name__,
            "error_message": error_str,
            "error_repr": error_repr,
            "traceback": error_traceback,
            "context": "run_exploit_lane",
        }
        _append_error_log(error_data)
        
        # Log to main log with truncated reason (for compatibility)
        event = MicroLaneEvent(
            ts=ts,
            symbol="",
            action="blocked",
            reason=f"runner_error: {error_str[:200]}",  # Truncate for compatibility
        )
        _append_log(event)
        
        return {
            "action": "blocked",
            "reason": f"runner_error: {error_str[:200]}",
            "ts": ts,
        }
    
    # Legacy code below (kept for reference but should not execute)
    if False:  # Disabled - using exploit_lane_runner instead
        # Load required data
        capital_plan = _load_json(CAPITAL_PLAN_PATH)
        capital_protection = _load_json(CAPITAL_PROTECTION_PATH)
        live_candidates = _load_json(LIVE_CANDIDATES_PATH)
        capital_momentum = _load_json(CAPITAL_MOMENTUM_PATH)
        state = _load_state()
        
        # Extract capital mode (handle different structures)
        capital_mode = capital_protection.get("mode")
        if not capital_mode:
            global_data = capital_protection.get("global", {})
            capital_mode = global_data.get("mode", "unknown")
        
        ts = datetime.now(timezone.utc).isoformat()
    
    # Check if we already have an open micro position (from our state)
    open_micro_pos = state.get("open_position", False)
    open_micro_symbol = state.get("symbol")
    
    # Verify the position still exists in position manager
    if open_micro_pos and open_micro_symbol:
        existing_pos = get_open_position(symbol=open_micro_symbol, timeframe="15m")
        if not existing_pos or existing_pos.get("dir", 0) == 0:
            # Position was closed, clear our state
            state["open_position"] = False
            state["symbol"] = None
            _save_state(state)
            open_micro_pos = False
        else:
            # We have an open micro position
            event = MicroLaneEvent(
                ts=ts,
                symbol="",
                action="blocked",
                reason=f"max_positions_reached (open_symbol={open_micro_symbol})",
            )
            _append_log(event)
            return {
                "action": "blocked",
                "reason": "max_positions_reached",
                "ts": ts,
            }
        event = MicroLaneEvent(
            ts=ts,
            symbol="",
            action="blocked",
            reason=f"max_positions_reached (count={open_count})",
        )
        _append_log(event)
        return {
            "action": "blocked",
            "reason": "max_positions_reached",
            "ts": ts,
        }
    
    # Check cooldown
    if not _check_cooldown(state):
        cooldown_until = state.get("cooldown_until", "")
        event = MicroLaneEvent(
            ts=ts,
            symbol="",
            action="blocked",
            reason=f"cooldown_active (until={cooldown_until})",
        )
        _append_log(event)
        return {
            "action": "blocked",
            "reason": "cooldown_active",
            "ts": ts,
        }
    
    # Select best eligible symbol
    best_result = _get_best_eligible_symbol(
        capital_plan,
        capital_protection,
        live_candidates,
        capital_momentum,
    )
    
    if not best_result:
        event = MicroLaneEvent(
            ts=ts,
            symbol="",
            action="blocked",
            reason="no_eligible_symbol",
            mode=capital_protection.get("mode", "unknown"),
        )
        _append_log(event)
        return {
            "action": "blocked",
            "reason": "no_eligible_symbol",
            "ts": ts,
        }
    
    symbol, symbol_data = best_result
    weight = symbol_data["weight"]
    
    # Check if symbol already has an open position
    existing_pos = get_open_position(symbol=symbol, timeframe="15m")
    if existing_pos and existing_pos.get("dir", 0) != 0:
        event = MicroLaneEvent(
            ts=ts,
            symbol=symbol,
            action="blocked",
            reason="position_already_open",
            weight=weight,
        )
        _append_log(event)
        return {
            "action": "blocked",
            "reason": "position_already_open",
            "symbol": symbol,
            "ts": ts,
        }
    
    # Get signal for entry decision
    try:
        signal_result = get_signal_vector(symbol=symbol)
        decision = decide(signal_result["signal_vector"], signal_result["raw_registry"])
        final = decision.get("final", {})
        direction = final.get("dir", 0)
        confidence = final.get("conf", 0.0)
        
        if direction == 0 or confidence < 0.55:
            event = MicroLaneEvent(
                ts=ts,
                symbol=symbol,
                action="blocked",
                reason=f"signal_not_ready (dir={direction}, conf={confidence:.2f})",
                weight=weight,
            )
            _append_log(event)
            return {
                "action": "blocked",
                "reason": "signal_not_ready",
                "symbol": symbol,
                "ts": ts,
            }
    except Exception as e:
        event = MicroLaneEvent(
            ts=ts,
            symbol=symbol,
            action="blocked",
            reason=f"signal_error: {str(e)}",
            weight=weight,
        )
        _append_log(event)
        return {
            "action": "blocked",
            "reason": "signal_error",
            "symbol": symbol,
            "ts": ts,
        }
    
    # Compute notional
    notional = _compute_notional(weight)
    
    # Attempt to open trade
    try:
        success = open_if_allowed(
            final_dir=direction,
            final_conf=confidence,
            entry_min_conf=0.55,
            risk_mult=1.0,
            symbol=symbol,
            timeframe="15m",
            exploration_pass=False,
        )
        
        if success:
            # Set cooldown
            _set_cooldown(state)
            
            # Update state (mark as micro position)
            state["open_position"] = True
            state["symbol"] = symbol
            state["side"] = "long" if direction == 1 else "short"
            state["entry_ts"] = ts
            state["notional"] = notional
            state["trade_kind"] = "exploit_micro"  # Tag for tracking
            _save_state(state)
            
            event = MicroLaneEvent(
                ts=ts,
                symbol=symbol,
                action="opened",
                reason="all_gates_passed",
                weight=weight,
                mode=capital_protection.get("mode", "unknown"),
                ready_now="Y",
                notional=notional,
                direction=direction,
                confidence=confidence,
            )
            _append_log(event)
            
            return {
                "action": "opened",
                "symbol": symbol,
                "direction": direction,
                "confidence": confidence,
                "notional": notional,
                "weight": weight,
                "ts": ts,
            }
        else:
            event = MicroLaneEvent(
                ts=ts,
                symbol=symbol,
                action="blocked",
                reason="open_if_allowed_returned_false",
                weight=weight,
                direction=direction,
                confidence=confidence,
            )
            _append_log(event)
            return {
                "action": "blocked",
                "reason": "open_if_allowed_returned_false",
                "symbol": symbol,
                "ts": ts,
            }
    except Exception as e:
        event = MicroLaneEvent(
            ts=ts,
            symbol=symbol,
            action="blocked",
            reason=f"execution_error: {str(e)}",
            weight=weight,
        )
        _append_log(event)
        return {
            "action": "blocked",
            "reason": f"execution_error: {str(e)}",
            "symbol": symbol,
            "ts": ts,
        }


def on_bar(symbol: str, current_price: float, direction: int, confidence: float, **kwargs) -> None:
    """
    Wrapper for per-bar evaluation (for integration with autonomous_trader).
    
    This is a lightweight wrapper that calls run_once() periodically.
    """
    # Only run periodically (e.g., every 5 minutes) to avoid excessive calls
    # For now, just call run_once - the cooldown will handle frequency
    try:
        run_once(reason="on_bar")
    except Exception:
        pass  # Fail silently to not break main loop

