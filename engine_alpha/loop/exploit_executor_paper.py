"""
Exploit Executor Paper (Phase 5c)
---------------------------------

PAPER-only executor for micro-paper exploit trades.

Hard safety gates:
- MODE == PAPER (raises if not PAPER)
- Enforces max concurrent exploit positions = 1
- Enforces max exploit opens/day per symbol and global/day
- Enforces max_notional_usd cap
- Kill switch if capital_mode != normal

Safety:
- PAPER-only (never places LIVE orders)
- Restrictive-only (never increases risk beyond caps)
"""

from __future__ import annotations

import json
import os
from dataclasses import dataclass, asdict
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Dict, Any, Optional

from engine_alpha.core.paths import REPORTS

# Paths
STATE_PATH = REPORTS / "exploit" / "exploit_state.json"
TRADES_LOG_PATH = REPORTS / "exploit" / "exploit_trades.jsonl"
PF_PATH = REPORTS / "exploit" / "exploit_pf.json"

# Defaults
DEFAULT_MAX_CONCURRENT = 1
DEFAULT_MAX_OPENS_PER_SYMBOL_PER_DAY = 3
DEFAULT_MAX_OPENS_GLOBAL_PER_DAY = 5
DEFAULT_MAX_NOTIONAL_USD = 100.0
DEFAULT_MIN_NOTIONAL_USD = 5.0


@dataclass
class ExploitPosition:
    """Open exploit position."""
    symbol: str
    direction: int  # 1 = long, -1 = short
    entry_price: float
    entry_ts: str
    notional_usd: float
    confidence: float
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


def _ensure_paper_mode() -> None:
    """Raise if not in PAPER mode."""
    mode = os.getenv("MODE", "").upper()
    if mode != "PAPER":
        raise RuntimeError(f"exploit_executor_paper requires MODE=PAPER, got MODE={mode}")


def _load_state() -> Dict[str, Any]:
    """Load exploit state."""
    STATE_PATH.parent.mkdir(parents=True, exist_ok=True)
    if not STATE_PATH.exists():
        return {
            "open_positions": {},
            "daily_opens": {},  # {symbol: count}
            "last_reset_ts": datetime.now(timezone.utc).isoformat(),
            "global_daily_opens": 0,
        }
    
    try:
        with STATE_PATH.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {
            "open_positions": {},
            "daily_opens": {},
            "last_reset_ts": datetime.now(timezone.utc).isoformat(),
            "global_daily_opens": 0,
        }


def _save_state(state: Dict[str, Any]) -> None:
    """Save exploit state."""
    STATE_PATH.parent.mkdir(parents=True, exist_ok=True)
    state["last_updated"] = datetime.now(timezone.utc).isoformat()
    try:
        with STATE_PATH.open("w", encoding="utf-8") as f:
            json.dump(state, f, indent=2)
    except Exception:
        pass


def _reset_daily_counters_if_needed(state: Dict[str, Any]) -> None:
    """Reset daily counters if a new day has started."""
    last_reset_str = state.get("last_reset_ts")
    if not last_reset_str:
        state["daily_opens"] = {}
        state["global_daily_opens"] = 0
        state["last_reset_ts"] = datetime.now(timezone.utc).isoformat()
        return
    
    try:
        last_reset = datetime.fromisoformat(last_reset_str.replace("Z", "+00:00"))
        now = datetime.now(timezone.utc)
        if (now - last_reset).days >= 1:
            state["daily_opens"] = {}
            state["global_daily_opens"] = 0
            state["last_reset_ts"] = now.isoformat()
    except Exception:
        state["daily_opens"] = {}
        state["global_daily_opens"] = 0
        state["last_reset_ts"] = datetime.now(timezone.utc).isoformat()


def can_open_exploit_trade(
    symbol: str,
    capital_mode: str,
    max_concurrent: int = DEFAULT_MAX_CONCURRENT,
    max_opens_per_symbol_per_day: int = DEFAULT_MAX_OPENS_PER_SYMBOL_PER_DAY,
    max_opens_global_per_day: int = DEFAULT_MAX_OPENS_GLOBAL_PER_DAY,
) -> tuple[bool, str]:
    """
    Check if an exploit trade can be opened.
    
    Returns:
        (can_open, reason)
    """
    _ensure_paper_mode()
    
    # Hard gate: capital mode must be normal
    if capital_mode != "normal":
        return False, f"capital_mode={capital_mode} (not 'normal')"
    
    # Load state
    state = _load_state()
    _reset_daily_counters_if_needed(state)
    
    # Check max concurrent positions
    open_positions = state.get("open_positions", {})
    if len(open_positions) >= max_concurrent:
        return False, f"max_concurrent={max_concurrent} reached"
    
    # Check if symbol already has open position
    if symbol in open_positions:
        return False, f"symbol {symbol} already has open position"
    
    # Check daily opens per symbol
    daily_opens = state.get("daily_opens", {})
    symbol_opens = daily_opens.get(symbol, 0)
    if symbol_opens >= max_opens_per_symbol_per_day:
        return False, f"max_opens_per_symbol_per_day={max_opens_per_symbol_per_day} reached for {symbol}"
    
    # Check global daily opens
    global_opens = state.get("global_daily_opens", 0)
    if global_opens >= max_opens_global_per_day:
        return False, f"max_opens_global_per_day={max_opens_global_per_day} reached"
    
    return True, "ok"


def open_exploit_trade(
    symbol: str,
    direction: int,
    entry_price: float,
    notional_usd: float,
    confidence: float,
) -> tuple[bool, str]:
    """
    Open an exploit trade (PAPER-only).
    
    Returns:
        (success, reason)
    """
    _ensure_paper_mode()
    
    # Load state
    state = _load_state()
    _reset_daily_counters_if_needed(state)
    
    # Create position
    position = ExploitPosition(
        symbol=symbol,
        direction=direction,
        entry_price=entry_price,
        entry_ts=datetime.now(timezone.utc).isoformat(),
        notional_usd=notional_usd,
        confidence=confidence,
    )
    
    # Update state
    open_positions = state.get("open_positions", {})
    open_positions[symbol] = position.to_dict()
    state["open_positions"] = open_positions
    
    # Update daily counters
    daily_opens = state.get("daily_opens", {})
    daily_opens[symbol] = daily_opens.get(symbol, 0) + 1
    state["daily_opens"] = daily_opens
    state["global_daily_opens"] = state.get("global_daily_opens", 0) + 1
    
    _save_state(state)
    
    # Log trade
    _log_trade({
        "ts": datetime.now(timezone.utc).isoformat(),
        "event": "open",
        "symbol": symbol,
        "direction": direction,
        "entry_price": entry_price,
        "notional_usd": notional_usd,
        "confidence": confidence,
    })
    
    return True, "opened"


def close_exploit_trade(
    symbol: str,
    exit_price: float,
    reason: str,
) -> tuple[bool, Optional[float], str]:
    """
    Close an exploit trade.
    
    Returns:
        (success, pnl_usd, reason)
    """
    _ensure_paper_mode()
    
    # Load state
    state = _load_state()
    open_positions = state.get("open_positions", {})
    
    if symbol not in open_positions:
        return False, None, f"no open position for {symbol}"
    
    position_data = open_positions[symbol]
    position = ExploitPosition(**position_data)
    
    # Compute PnL
    entry_price = position.entry_price
    direction = position.direction
    notional_usd = position.notional_usd
    
    if direction == 1:  # long
        pnl_pct = (exit_price - entry_price) / entry_price
    else:  # short
        pnl_pct = (entry_price - exit_price) / entry_price
    
    pnl_usd = notional_usd * pnl_pct
    
    # Remove position
    del open_positions[symbol]
    state["open_positions"] = open_positions
    _save_state(state)
    
    # Log trade
    _log_trade({
        "ts": datetime.now(timezone.utc).isoformat(),
        "event": "close",
        "symbol": symbol,
        "direction": direction,
        "entry_price": entry_price,
        "exit_price": exit_price,
        "notional_usd": notional_usd,
        "pnl_pct": pnl_pct,
        "pnl_usd": pnl_usd,
        "reason": reason,
    })
    
    return True, pnl_usd, "closed"


def get_open_positions() -> Dict[str, ExploitPosition]:
    """Get all open exploit positions."""
    state = _load_state()
    open_positions = state.get("open_positions", {})
    result = {}
    for sym, pos_data in open_positions.items():
        try:
            result[sym] = ExploitPosition(**pos_data)
        except Exception:
            continue
    return result


def _log_trade(event: Dict[str, Any]) -> None:
    """Log exploit trade event."""
    TRADES_LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
    try:
        with TRADES_LOG_PATH.open("a", encoding="utf-8") as f:
            f.write(json.dumps(event) + "\n")
    except Exception:
        pass


__all__ = [
    "can_open_exploit_trade",
    "open_exploit_trade",
    "close_exploit_trade",
    "get_open_positions",
    "ExploitPosition",
]

