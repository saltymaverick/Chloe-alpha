"""
Shadow Exploit Scorer (Phase 5b)
----------------------------------

Computes quant-grade metrics from shadow exploit lane events.

Inputs:
  - reports/reflect/shadow_exploit_log.jsonl (events from Phase 5a)
  - reports/reflect/shadow_exploit_state.json (optional)

Outputs:
  - reports/reflect/shadow_exploit_scores.json
  - reports/reflect/shadow_exploit_pf.json (PF snapshot)
"""

from __future__ import annotations

import json
from collections import defaultdict
from dataclasses import dataclass, asdict
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple

from engine_alpha.core.paths import REPORTS

LOG_PATH = REPORTS / "reflect" / "shadow_exploit_log.jsonl"
STATE_PATH = REPORTS / "reflect" / "shadow_exploit_state.json"
SCORES_PATH = REPORTS / "reflect" / "shadow_exploit_scores.json"
PF_PATH = REPORTS / "reflect" / "shadow_exploit_pf.json"

# Bayesian PF priors (to avoid infinite PF early)
PF_PRIOR_WIN_USD = 1.0
PF_PRIOR_LOSS_USD = 1.0


@dataclass
class SymbolMetrics:
    """Per-symbol shadow exploit metrics."""
    symbol: str
    trades: int
    wins: int
    losses: int
    win_rate: float
    avg_win_pct: float
    avg_loss_pct: float
    expectancy_pct: float
    profit_factor: Optional[float]
    sum_pos: float
    sum_neg: float
    max_drawdown_pct: float
    last_trade_ts: Optional[str]
    last_open_ts: Optional[str]
    pf_1d: Optional[float]
    pf_7d: Optional[float]
    pf_30d: Optional[float]
    trades_1d: int
    trades_7d: int
    trades_30d: int
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


def _load_events() -> List[Dict[str, Any]]:
    """Load all shadow exploit events from JSONL."""
    # Ensure directory exists
    LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
    
    if not LOG_PATH.exists():
        return []
    
    events = []
    try:
        with LOG_PATH.open("r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    event = json.loads(line)
                    events.append(event)
                except Exception:
                    continue
    except Exception:
        pass
    
    return events


def _parse_timestamp(ts_str: str) -> datetime:
    """Parse ISO timestamp."""
    try:
        if ts_str.endswith("Z"):
            ts_str = ts_str[:-1] + "+00:00"
        return datetime.fromisoformat(ts_str.replace("Z", "+00:00"))
    except Exception:
        return datetime.now(timezone.utc)


def _calculate_pf_from_trades(trades: List[Dict[str, Any]]) -> Tuple[Optional[float], float, float, float, float]:
    """
    Calculate profit factor from trades (raw, stable, and display).
    
    Returns:
        (pf_raw, pf_stable, pf_display, positive_sum, negative_sum)
    """
    positive_sum = 0.0
    negative_sum = 0.0
    
    for trade in trades:
        pnl = trade.get("pnl_pct")
        if pnl is None:
            continue
        pnl_val = float(pnl)
        if pnl_val > 0:
            positive_sum += pnl_val
        else:
            negative_sum += abs(pnl_val)
    
    # Raw PF (can be None if no losses, or infinity if wins but no losses)
    negative_sum_abs = abs(negative_sum)
    if negative_sum_abs == 0:
        if positive_sum > 0:
            pf_raw = None  # Infinite (represented as None)
        else:
            pf_raw = 1.0  # No trades
    else:
        pf_raw = positive_sum / negative_sum_abs
    
    # Stable PF (Bayesian with priors - always finite)
    pf_stable = (positive_sum + PF_PRIOR_WIN_USD) / (negative_sum_abs + PF_PRIOR_LOSS_USD)
    
    # Display PF (usually equals stable, but allows future overrides)
    pf_display = pf_stable
    
    return pf_raw, pf_stable, pf_display, positive_sum, negative_sum


def _calculate_max_drawdown(trades: List[Dict[str, Any]]) -> float:
    """Calculate max drawdown from cumulative PnL."""
    if not trades:
        return 0.0
    
    cumulative = 0.0
    peak = 0.0
    max_dd = 0.0
    
    for trade in sorted(trades, key=lambda t: _parse_timestamp(t.get("ts", ""))):
        pnl = trade.get("pnl_pct")
        if pnl is None:
            continue
        cumulative += float(pnl)
        if cumulative > peak:
            peak = cumulative
        dd = peak - cumulative
        if dd > max_dd:
            max_dd = dd
    
    return max_dd


def _filter_trades_by_window(trades: List[Dict[str, Any]], window_days: int) -> List[Dict[str, Any]]:
    """Filter trades within time window."""
    now = datetime.now(timezone.utc)
    cutoff = now - timedelta(days=window_days)
    
    filtered = []
    for trade in trades:
        ts_str = trade.get("ts")
        if not ts_str:
            continue
        try:
            ts = _parse_timestamp(ts_str)
            if ts >= cutoff:
                filtered.append(trade)
        except Exception:
            continue
    
    return filtered


def _compute_symbol_metrics(symbol: str, events: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Compute metrics for a single symbol."""
    # Filter to exit events (completed trades)
    # Handle both "action" and "event" field names for compatibility
    exits = [
        e for e in events 
        if e.get("symbol") == symbol 
        and (e.get("action") == "would_exit" or e.get("event") == "would_exit")
        and e.get("pnl_pct") is not None
    ]
    
    # Get all opens for this symbol
    opens = [
        e for e in events 
        if e.get("symbol") == symbol 
        and (e.get("action") == "would_open" or e.get("event") == "would_open")
    ]
    
    trades = exits
    trades_count = len(trades)
    
    if trades_count == 0:
        # Return dict format (no trades case)
        # Phase 5H.2 Cleanup: Return None for PF when trades=0 (display as "—")
        return {
            "symbol": symbol,
            "trades": 0,
            "wins": 0,
            "losses": 0,
            "win_rate": 0.0,
            "avg_win_pct": 0.0,
            "avg_loss_pct": 0.0,
            "expectancy_pct": 0.0,
            "profit_factor": None,  # Phase 5H.2 Cleanup: None when trades=0 (display as "—")
            "profit_factor_raw": None,
            "profit_factor_stable": 1.0,
            "profit_factor_display": None,  # Phase 5H.2 Cleanup: None when trades=0
            "sum_pos": 0.0,
            "sum_neg": 0.0,
            "max_drawdown_pct": 0.0,
            "last_trade_ts": None,
            "last_open_ts": opens[-1].get("ts") if opens else None,
            "pf_1d": None,  # Phase 5H.2 Cleanup: None when trades=0 (display as "—")
            "pf_7d": None,  # Phase 5H.2 Cleanup: None when trades=0 (display as "—")
            "pf_30d": None,  # Phase 5H.2 Cleanup: None when trades=0 (display as "—")
            "pf_1d_raw": None,
            "pf_1d_stable": 1.0,
            "pf_1d_display": None,  # Phase 5H.2 Cleanup: None when trades=0
            "pf_7d_raw": None,
            "pf_7d_stable": 1.0,
            "pf_7d_display": None,  # Phase 5H.2 Cleanup: None when trades=0
            "pf_30d_raw": None,
            "pf_30d_stable": 1.0,
            "pf_30d_display": None,  # Phase 5H.2 Cleanup: None when trades=0
            "trades_1d": 0,
            "trades_7d": 0,
            "trades_30d": 0,
        }
    
    # Basic stats
    wins = [t for t in trades if float(t.get("pnl_pct", 0)) > 0]
    losses = [t for t in trades if float(t.get("pnl_pct", 0)) <= 0]
    wins_count = len(wins)
    losses_count = len(losses)
    win_rate = wins_count / trades_count if trades_count > 0 else 0.0
    
    avg_win = sum(float(t.get("pnl_pct", 0)) for t in wins) / wins_count if wins_count > 0 else 0.0
    avg_loss = sum(float(t.get("pnl_pct", 0)) for t in losses) / losses_count if losses_count > 0 else 0.0
    expectancy = win_rate * avg_win + (1 - win_rate) * avg_loss
    
    # Profit factor (raw, stable, display)
    pf_raw, pf_stable, pf_display, sum_pos, sum_neg = _calculate_pf_from_trades(trades)
    
    # Max drawdown
    max_dd = _calculate_max_drawdown(trades)
    
    # Last trade/open timestamps
    last_trade_ts = trades[-1].get("ts") if trades else None
    last_open_ts = opens[-1].get("ts") if opens else None
    
    # Rolling PF windows (compute raw, stable, display)
    trades_1d = _filter_trades_by_window(trades, 1)
    trades_7d = _filter_trades_by_window(trades, 7)
    trades_30d = _filter_trades_by_window(trades, 30)
    
    pf_1d_raw, pf_1d_stable, pf_1d_display, _, _ = _calculate_pf_from_trades(trades_1d) if trades_1d else (None, 1.0, 1.0, 0.0, 0.0)
    pf_7d_raw, pf_7d_stable, pf_7d_display, _, _ = _calculate_pf_from_trades(trades_7d) if trades_7d else (None, 1.0, 1.0, 0.0, 0.0)
    pf_30d_raw, pf_30d_stable, pf_30d_display, _, _ = _calculate_pf_from_trades(trades_30d) if trades_30d else (None, 1.0, 1.0, 0.0, 0.0)
    
    metrics = SymbolMetrics(
        symbol=symbol,
        trades=trades_count,
        wins=wins_count,
        losses=losses_count,
        win_rate=win_rate,
        avg_win_pct=avg_win,
        avg_loss_pct=avg_loss,
        expectancy_pct=expectancy,
        profit_factor=pf_display,  # Backward compatible: pf = pf_display
        sum_pos=sum_pos,
        sum_neg=sum_neg,
        max_drawdown_pct=max_dd,
        last_trade_ts=last_trade_ts,
        last_open_ts=last_open_ts,
        pf_1d=pf_1d_display,  # Backward compatible: pf_1d = pf_1d_display
        pf_7d=pf_7d_display,  # Backward compatible: pf_7d = pf_7d_display
        pf_30d=pf_30d_display,  # Backward compatible: pf_30d = pf_30d_display
        trades_1d=len(trades_1d),
        trades_7d=len(trades_7d),
        trades_30d=len(trades_30d),
    )
    
    # Add explicit schema fields (raw, stable, display)
    metrics_dict = metrics.to_dict()
    metrics_dict["profit_factor_raw"] = pf_raw
    metrics_dict["profit_factor_stable"] = pf_stable
    metrics_dict["profit_factor_display"] = pf_display
    metrics_dict["pf_1d_raw"] = pf_1d_raw
    metrics_dict["pf_1d_stable"] = pf_1d_stable
    metrics_dict["pf_1d_display"] = pf_1d_display
    metrics_dict["pf_7d_raw"] = pf_7d_raw
    metrics_dict["pf_7d_stable"] = pf_7d_stable
    metrics_dict["pf_7d_display"] = pf_7d_display
    metrics_dict["pf_30d_raw"] = pf_30d_raw
    metrics_dict["pf_30d_stable"] = pf_30d_stable
    metrics_dict["pf_30d_display"] = pf_30d_display
    
    return metrics_dict


def _compute_global_metrics(all_events: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Compute global aggregated metrics."""
    # Get all exit events (handle both "action" and "event" field names)
    all_exits = [
        e for e in all_events 
        if (e.get("action") == "would_exit" or e.get("event") == "would_exit")
        and e.get("pnl_pct") is not None
    ]
    
    if not all_exits:
        return {
            "trades": 0,
            "wins": 0,
            "losses": 0,
            "win_rate": 0.0,
            "avg_win_pct": 0.0,
            "avg_loss_pct": 0.0,
            "expectancy_pct": 0.0,
            "profit_factor": None,
            "sum_pos": 0.0,
            "sum_neg": 0.0,
            "max_drawdown_pct": 0.0,
            "pf_1d": None,
            "pf_7d": None,
            "pf_30d": None,
            "trades_1d": 0,
            "trades_7d": 0,
            "trades_30d": 0,
        }
    
    # Basic stats
    wins = [t for t in all_exits if float(t.get("pnl_pct", 0)) > 0]
    losses = [t for t in all_exits if float(t.get("pnl_pct", 0)) <= 0]
    wins_count = len(wins)
    losses_count = len(losses)
    trades_count = len(all_exits)
    win_rate = wins_count / trades_count if trades_count > 0 else 0.0
    
    avg_win = sum(float(t.get("pnl_pct", 0)) for t in wins) / wins_count if wins_count > 0 else 0.0
    avg_loss = sum(float(t.get("pnl_pct", 0)) for t in losses) / losses_count if losses_count > 0 else 0.0
    expectancy = win_rate * avg_win + (1 - win_rate) * avg_loss
    
    # Profit factor (raw, stable, display)
    pf_raw, pf_stable, pf_display, sum_pos, sum_neg = _calculate_pf_from_trades(all_exits)
    
    # Max drawdown
    max_dd = _calculate_max_drawdown(all_exits)
    
    # Rolling PF windows (compute raw, stable, display)
    trades_1d = _filter_trades_by_window(all_exits, 1)
    trades_7d = _filter_trades_by_window(all_exits, 7)
    trades_30d = _filter_trades_by_window(all_exits, 30)
    
    pf_1d_raw, pf_1d_stable, pf_1d_display, _, _ = _calculate_pf_from_trades(trades_1d) if trades_1d else (None, 1.0, 1.0, 0.0, 0.0)
    pf_7d_raw, pf_7d_stable, pf_7d_display, _, _ = _calculate_pf_from_trades(trades_7d) if trades_7d else (None, 1.0, 1.0, 0.0, 0.0)
    pf_30d_raw, pf_30d_stable, pf_30d_display, _, _ = _calculate_pf_from_trades(trades_30d) if trades_30d else (None, 1.0, 1.0, 0.0, 0.0)
    
    return {
        "trades": trades_count,
        "wins": wins_count,
        "losses": losses_count,
        "win_rate": win_rate,
        "avg_win_pct": avg_win,
        "avg_loss_pct": avg_loss,
        "expectancy_pct": expectancy,
        "profit_factor": pf_display,  # Backward compatible: pf = pf_display
        "profit_factor_raw": pf_raw,  # Raw PF (truth, can be None/∞)
        "profit_factor_stable": pf_stable,  # Stable PF (Bayesian)
        "profit_factor_display": pf_display,  # Display PF (for dashboards/gates)
        "sum_pos": sum_pos,
        "sum_neg": sum_neg,
        "max_drawdown_pct": max_dd,
        "pf_1d": pf_1d_display,  # Backward compatible: pf_1d = pf_1d_display
        "pf_7d": pf_7d_display,  # Backward compatible: pf_7d = pf_7d_display
        "pf_30d": pf_30d_display,  # Backward compatible: pf_30d = pf_30d_display
        "pf_1d_raw": pf_1d_raw,
        "pf_1d_stable": pf_1d_stable,
        "pf_1d_display": pf_1d_display,
        "pf_7d_raw": pf_7d_raw,
        "pf_7d_stable": pf_7d_stable,
        "pf_7d_display": pf_7d_display,
        "pf_30d_raw": pf_30d_raw,
        "pf_30d_stable": pf_30d_stable,
        "pf_30d_display": pf_30d_display,
        "trades_1d": len(trades_1d),
        "trades_7d": len(trades_7d),
        "trades_30d": len(trades_30d),
    }


def compute_shadow_scores() -> Dict[str, Any]:
    """
    Compute shadow exploit scores from events.
    
    Returns:
        Dict with scores data
    """
    events = _load_events()
    
    # Extract unique symbols
    symbols = set()
    for event in events:
        sym = event.get("symbol")
        if sym:
            symbols.add(sym)
    
    # Compute per-symbol metrics
    by_symbol = {}
    for symbol in sorted(symbols):
        metrics_dict = _compute_symbol_metrics(symbol, events)
        by_symbol[symbol] = metrics_dict  # Already a dict with raw/stable PF fields
    
    # Compute global metrics
    global_metrics = _compute_global_metrics(events)
    
    # Data health
    exits = [e for e in events if e.get("action") == "would_exit"]
    
    data_health = {
        "log_found": LOG_PATH.exists(),
        "events": len(events),
        "exits": len(exits),
    }
    
    notes = []
    if not LOG_PATH.exists():
        notes.append("Shadow exploit log not found. No events to score.")
    elif len(events) == 0:
        notes.append("Shadow exploit log is empty. No events to score.")
    elif len(exits) == 0:
        notes.append("No completed trades (would_exit events) found. Metrics will be zero.")
    else:
        notes.append(f"Processing {len(exits)} completed trades from {len(events)} total events.")
    
    result = {
        "engine": "shadow_exploit_scorer_v1",
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "global": global_metrics,
        "by_symbol": by_symbol,
        "notes": notes,
        "data_health": data_health,
    }
    
    # Save scores
    SCORES_PATH.parent.mkdir(parents=True, exist_ok=True)
    with SCORES_PATH.open("w", encoding="utf-8") as f:
        json.dump(result, f, indent=2)
    
    # Save PF snapshot (compatibility format)
    pf_snapshot = {
        "engine": "shadow_exploit_pf_v1",
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "global": {
            "pf_1d": global_metrics.get("pf_1d"),
            "pf_7d": global_metrics.get("pf_7d"),
            "pf_30d": global_metrics.get("pf_30d"),
            "trades_1d": global_metrics.get("trades_1d"),
            "trades_7d": global_metrics.get("trades_7d"),
            "trades_30d": global_metrics.get("trades_30d"),
        },
        "by_symbol": {
            sym: {
                "pf_1d": data.get("pf_1d"),
                "pf_7d": data.get("pf_7d"),
                "pf_30d": data.get("pf_30d"),
                "trades_1d": data.get("trades_1d"),
                "trades_7d": data.get("trades_7d"),
                "trades_30d": data.get("trades_30d"),
            }
            for sym, data in by_symbol.items()
        },
    }
    
    PF_PATH.parent.mkdir(parents=True, exist_ok=True)
    with PF_PATH.open("w", encoding="utf-8") as f:
        json.dump(pf_snapshot, f, indent=2)
    
    return result

