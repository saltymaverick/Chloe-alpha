#!/usr/bin/env python3
"""
Exploit Stack Syntax Check
---------------------------

Hard guardrail to prevent silent syntax failures in the exploit execution stack.
Runs py_compile over all exploit-related modules and reports PASS/FAIL.

Exit codes:
- 0: All files compile successfully
- 2: One or more files have syntax errors
"""

from __future__ import annotations

import sys
import py_compile
from pathlib import Path
from typing import List, Tuple

# Files to check (exploit execution stack)
EXPLOIT_STACK_FILES = [
    "engine_alpha/loop/exploit_lane_runner.py",
    "engine_alpha/loop/exploit_micro_lane.py",
    "engine_alpha/loop/exploit_arming.py",
    "engine_alpha/loop/promotion_gate.py",
    "engine_alpha/loop/probe_lane.py",
    "engine_alpha/loop/probe_lane_gate.py",
    "engine_alpha/reflect/shadow_exploit_lane.py",
    "tools/chloe_orchestrator.py",
    "tools/run_exploit_lane_runner.py",
]

ROOT = Path(__file__).resolve().parents[1]


def check_syntax() -> Tuple[bool, List[Tuple[str, str]]]:
    """
    Check syntax of all exploit stack files.
    
    Returns:
        (all_passed, [(file, error), ...])
    """
    errors = []
    
    for rel_path in EXPLOIT_STACK_FILES:
        file_path = ROOT / rel_path
        
        if not file_path.exists():
            errors.append((rel_path, f"File not found: {file_path}"))
            continue
        
        try:
            py_compile.compile(str(file_path), doraise=True)
        except py_compile.PyCompileError as e:
            errors.append((rel_path, str(e)))
        except Exception as e:
            errors.append((rel_path, f"Unexpected error: {str(e)}"))
    
    return len(errors) == 0, errors


def main() -> int:
    """Run syntax check and print report."""
    print("EXPLOIT STACK SYNTAX CHECK")
    print("=" * 70)
    
    all_passed, errors = check_syntax()
    
    if all_passed:
        print("✓ PASS: All exploit stack files compile successfully")
        print()
        print("Checked files:")
        for rel_path in EXPLOIT_STACK_FILES:
            print(f"  ✓ {rel_path}")
        print()
        return 0
    else:
        print("✗ FAIL: Syntax errors detected")
        print()
        print("Errors:")
        for rel_path, error_msg in errors:
            print(f"  ✗ {rel_path}")
            # Extract line number if present
            if "line" in error_msg.lower():
                lines = error_msg.split("\n")
                for line in lines[:3]:  # Show first 3 lines of error
                    if line.strip():
                        print(f"    {line}")
            else:
                print(f"    {error_msg}")
        print()
        print("=" * 70)
        return 2


if __name__ == "__main__":
    sys.exit(main())

