"""
Shadow Exploit Lane (Phase 5a)
-------------------------------

PAPER-only "would-have-traded" mirror for exploit lane decisions.

This module:
  - Evaluates exploit lane decisions continuously
  - NEVER places orders (zero order path guaranteed)
  - Maintains shadow position state
  - Computes shadow PnL using current prices
  - Logs "would_open", "would_exit", "would_block" events

Safety:
  - PAPER-only
  - Restrictive-only (never enables trading)
  - Read-only (does not modify positions or configs)
  - No executor imports (guaranteed no order placement)
"""

from __future__ import annotations

import hashlib
import json
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple

from engine_alpha.core.paths import REPORTS, CONFIG
from engine_alpha.data.live_prices import get_live_ohlcv
import yaml

# Paths
CAPITAL_PROTECTION_PATH = REPORTS / "risk" / "capital_protection.json"
CAPITAL_PLAN_PATH = REPORTS / "risk" / "capital_plan.json"
LIVE_CANDIDATES_PATH = REPORTS / "risk" / "live_candidates.json"
POLICY_PATH = REPORTS / "research" / "exploration_policy_v3.json"
RISK_SNAPSHOT_PATH = REPORTS / "risk" / "risk_snapshot.json"
LOG_PATH = REPORTS / "reflect" / "shadow_exploit_log.jsonl"
STATE_PATH = REPORTS / "reflect" / "shadow_exploit_state.json"
PF_PATH = REPORTS / "reflect" / "shadow_exploit_pf.json"

# Minimum weight threshold (configurable)
MIN_WEIGHT_THRESHOLD = 0.20


@dataclass
class ShadowEvent:
    """Shadow exploit lane event."""
    ts: str
    symbol: str
    action: str  # "would_open", "would_exit", "would_block", "would_hold"
    reason: str
    mode: Optional[str] = None
    policy_level: Optional[str] = None
    allow_new_entries: Optional[bool] = None
    lane_intent: Optional[str] = None
    weight: Optional[float] = None
    ready_now: Optional[str] = None
    live_ready: Optional[str] = None
    blocked: Optional[bool] = None
    direction: Optional[int] = None  # 1 = long, -1 = short, 0 = flat
    confidence: Optional[float] = None
    entry_price: Optional[float] = None
    exit_price: Optional[float] = None
    pnl_pct: Optional[float] = None
    notional_usd: Optional[float] = None  # Shadow notional from position sizer
    pnl_usd: Optional[float] = None  # USD PnL (notional * pnl_pct)
    shadow_only: Optional[bool] = None  # True if this is shadow simulation (gate blocked)
    blocked_reason: Optional[str] = None  # Reason gate blocked (if shadow_only=True)
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class ShadowPosition:
    """Shadow position state."""
    symbol: str
    direction: int  # 1 = long, -1 = short
    entry_price: float
    entry_ts: str
    entry_confidence: float
    bars_open: int = 0
    notional_usd: Optional[float] = None  # Shadow notional from position sizer
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


def _load_json(path: Path) -> Dict[str, Any]:
    """Safely load JSON file."""
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def _save_json(path: Path, data: Dict[str, Any]) -> None:
    """Safely save JSON file."""
    path.parent.mkdir(parents=True, exist_ok=True)
    try:
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    except Exception:
        pass


def _load_shadow_state() -> Dict[str, ShadowPosition]:
    """Load shadow position state."""
    if not STATE_PATH.exists():
        return {}
    
    try:
        data = _load_json(STATE_PATH)
        positions = {}
        for sym, pos_data in data.get("positions", {}).items():
            positions[sym] = ShadowPosition(**pos_data)
        return positions
    except Exception:
        return {}


def _save_shadow_state(positions: Dict[str, ShadowPosition]) -> None:
    """Save shadow position state."""
    data = {
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "positions": {sym: pos.to_dict() for sym, pos in positions.items()},
    }
    _save_json(STATE_PATH, data)


def _log_event(event: ShadowEvent) -> None:
    """Log shadow event to JSONL."""
    LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
    try:
        with LOG_PATH.open("a", encoding="utf-8") as f:
            f.write(json.dumps(event.to_dict()) + "\n")
    except Exception:
        pass


def _get_current_price(symbol: str, timeframe: str = "15m") -> Optional[float]:
    """Get current price from OHLCV data."""
    try:
        rows = get_live_ohlcv(symbol, timeframe, limit=1)
        if rows and len(rows) > 0:
            return float(rows[-1].get("close", 0))
    except Exception:
        pass
    return None


def _get_equity_usd() -> float:
    """Get current equity in USD from config."""
    defaults = {"start_equity": 10000.0}
    cfg_path = CONFIG / "risk.yaml"
    if not cfg_path.exists():
        return defaults["start_equity"]
    try:
        data = yaml.safe_load(cfg_path.read_text()) or {}
        accounting = data.get("accounting", {})
        return float(accounting.get("start_equity", defaults["start_equity"]))
    except Exception:
        return defaults["start_equity"]


def _compute_shadow_pf(events: List[ShadowEvent]) -> Dict[str, Any]:
    """Compute shadow PF from events."""
    now = datetime.now(timezone.utc)
    
    # Filter to exit events with PnL
    exits = [e for e in events if e.action == "would_exit" and e.pnl_pct is not None]
    
    if not exits:
        return {
            "pf_1d": None,
            "pf_7d": None,
            "pf_30d": None,
            "trades_1d": 0,
            "trades_7d": 0,
            "trades_30d": 0,
        }
    
    # Group by time windows
    wins_1d = []
    losses_1d = []
    wins_7d = []
    losses_7d = []
    wins_30d = []
    losses_30d = []
    
    for exit_event in exits:
        try:
            event_ts = datetime.fromisoformat(exit_event.ts.replace("Z", "+00:00"))
            age_seconds = (now - event_ts).total_seconds()
            
            pnl = exit_event.pnl_pct or 0.0
            
            if age_seconds <= 86400:  # 1 day
                if pnl > 0:
                    wins_1d.append(abs(pnl))
                else:
                    losses_1d.append(abs(pnl))
            
            if age_seconds <= 604800:  # 7 days
                if pnl > 0:
                    wins_7d.append(abs(pnl))
                else:
                    losses_7d.append(abs(pnl))
            
            if age_seconds <= 2592000:  # 30 days
                if pnl > 0:
                    wins_30d.append(abs(pnl))
                else:
                    losses_30d.append(abs(pnl))
        except Exception:
            continue
    
    def _pf(wins: List[float], losses: List[float]) -> Optional[float]:
        if not wins and not losses:
            return None
        win_sum = sum(wins) if wins else 0.0
        loss_sum = sum(losses) if losses else 0.0
        if loss_sum == 0:
            return 999.0 if win_sum > 0 else None
        return win_sum / loss_sum
    
    return {
        "pf_1d": _pf(wins_1d, losses_1d),
        "pf_7d": _pf(wins_7d, losses_7d),
        "pf_30d": _pf(wins_30d, losses_30d),
        "trades_1d": len(wins_1d) + len(losses_1d),
        "trades_7d": len(wins_7d) + len(losses_7d),
        "trades_30d": len(wins_30d) + len(losses_30d),
    }


def _evaluate_exploit_decision(
    symbol: str,
    direction: int,
    confidence: float,
    current_price: Optional[float],
) -> Tuple[bool, str, Dict[str, Any]]:
    """
    Evaluate if exploit lane would allow this trade.
    
    Returns:
        (would_allow, reason, context_dict)
    """
    # Load all inputs
    capital_protection = _load_json(CAPITAL_PROTECTION_PATH)
    capital_plan = _load_json(CAPITAL_PLAN_PATH)
    live_candidates = _load_json(LIVE_CANDIDATES_PATH)
    policy = _load_json(POLICY_PATH)
    risk_snapshot = _load_json(RISK_SNAPSHOT_PATH)
    
    # Extract global mode
    global_mode = capital_protection.get("global", {})
    mode = global_mode.get("mode")
    
    # Extract symbol data
    symbols_plan = capital_plan.get("symbols", {})
    symbol_entry = symbols_plan.get(symbol, {})
    lane_intent = symbol_entry.get("lane_intent")
    weight = symbol_entry.get("weight", 0.0)
    
    symbols_lc = live_candidates.get("symbols", {})
    symbol_lc = symbols_lc.get(symbol, {})
    ready_now_raw = symbol_lc.get("ready_now") or symbol_lc.get("ReadyNow") or symbol_lc.get("ready")
    
    from engine_alpha.risk.exploit_lane_gate import is_ready_now
    ready_now_bool = is_ready_now(ready_now_raw)
    
    symbols_policy = policy.get("symbols", {})
    symbol_policy = symbols_policy.get(symbol, {})
    policy_level = symbol_policy.get("level")
    allow_new_entries = symbol_policy.get("allow_new_entries", True)
    
    symbols_risk = risk_snapshot.get("symbols", {})
    symbol_risk = symbols_risk.get(symbol, {})
    blocked = symbol_risk.get("blocked", False)
    
    context = {
        "mode": mode,
        "policy_level": policy_level,
        "allow_new_entries": allow_new_entries,
        "lane_intent": lane_intent,
        "weight": weight,
        "ready_now": "Y" if ready_now_bool else "N",
        "blocked": blocked,
    }
    
    # Gate logic (same as exploit_lane_gate)
    if mode == "halt_new_entries":
        return False, f"CapitalProtection=halt_new_entries", context
    
    if policy_level == "blocked" or allow_new_entries is False:
        return False, f"Policy blocked: level={policy_level}", context
    
    if lane_intent != "exploit":
        return False, f"Lane intent mismatch: {lane_intent} (expected 'exploit')", context
    
    if blocked:
        return False, "Risk snapshot blocked=True", context
    
    if not ready_now_bool:
        return False, "ready_now=False", context
    
    if mode == "de_risk":
        if weight is None or weight < 0.20:
            return False, f"de_risk: weight={weight} < 0.20", context
        
        # Check if rank #1
        all_weights = []
        for sym, entry in symbols_plan.items():
            w = entry.get("weight", 0.0)
            if w is not None:
                all_weights.append((sym, w))
        
        if all_weights:
            all_weights.sort(key=lambda x: x[1], reverse=True)
            top_symbol = all_weights[0][0]
            if symbol != top_symbol:
                return False, f"de_risk: not rank #1 (top={top_symbol})", context
    
    if mode == "normal":
        if weight is None or weight < 0.05:
            return False, f"Weight too low: {weight} < 0.05", context
        
        if not ready_now_bool and (weight is None or weight < 0.20):
            return False, f"Not ready_now and weight={weight} < 0.20", context
    
    if mode != "normal" and mode != "de_risk":
        return False, f"Unknown capital mode: {mode}", context
    
    # Would allow
    return True, f"Passed exploit gate (mode={mode}, weight={weight:.3f})", context


def evaluate_all_eligible_symbols() -> None:
    """
    Evaluate ALL eligible symbols and emit events for each.
    
    This ensures we always have data, even when no trades are happening.
    Called from orchestrator to guarantee continuous event emission.
    """
    # Load all required data
    capital_plan = _load_json(CAPITAL_PLAN_PATH)
    capital_protection = _load_json(CAPITAL_PROTECTION_PATH)
    live_candidates = _load_json(LIVE_CANDIDATES_PATH)
    policy = _load_json(POLICY_PATH)
    risk_snapshot = _load_json(RISK_SNAPSHOT_PATH)
    
    # Get capital mode
    global_mode = capital_protection.get("global", {})
    capital_mode = global_mode.get("mode", "unknown")
    
    # Get all symbols with exploit intent
    symbols_plan = capital_plan.get("symbols", {})
    if not symbols_plan:
        return
    
    # Load shadow state
    positions = _load_shadow_state()
    
    # Evaluate each symbol
    for symbol, plan_data in symbols_plan.items():
        lane_intent = plan_data.get("lane_intent")
        weight = plan_data.get("weight", 0.0)
        
        # Only evaluate exploit-intent symbols
        if lane_intent != "exploit":
            continue
        
        # Get symbol data
        symbols_lc = live_candidates.get("symbols", {})
        symbol_lc = symbols_lc.get(symbol, {})
        ready_now_raw = symbol_lc.get("ready_now") or symbol_lc.get("ReadyNow") or symbol_lc.get("ready")
        
        from engine_alpha.risk.exploit_lane_gate import is_ready_now
        ready_now_bool = is_ready_now(ready_now_raw)
        
        symbols_policy = policy.get("symbols", {})
        symbol_policy = symbols_policy.get(symbol, {})
        policy_level = symbol_policy.get("level")
        allow_new_entries = symbol_policy.get("allow_new_entries", True)
        
        symbols_risk = risk_snapshot.get("symbols", {})
        symbol_risk = symbols_risk.get(symbol, {})
        blocked = symbol_risk.get("blocked", False)
        
        # Get exploit intent using shared pipeline (same as real trading loop)
        try:
            from engine_alpha.loop.exploit_intent import compute_exploit_intent
            intent = compute_exploit_intent(symbol=symbol, timeframe="15m")
            direction = intent.get("direction", 0)
            confidence = intent.get("confidence", 0.0)
            # Always get current price from OHLCV (intent may not have it)
            current_price = _get_current_price(symbol, "15m")
        except Exception:
            # Fallback to old method if intent generator fails
            current_price = _get_current_price(symbol, "15m")
            direction = 0
            confidence = 0.0
        
        # Get PF validity for sizing
        pf_validity_data = _load_json(REPORTS / "risk" / "pf_validity.json")
        validity_entry = pf_validity_data.get("by_symbol", {}).get(symbol, {})
        pf_validity = validity_entry.get("validity_score", 0.5)
        
        # Get tier from capital plan
        tier = plan_data.get("tier", "tier3")
        
        # Check if we have an open shadow position
        shadow_pos = positions.get(symbol)
        
        context = {
            "mode": capital_mode,
            "policy_level": policy_level,
            "allow_new_entries": allow_new_entries,
            "lane_intent": lane_intent,
            "weight": weight,
            "ready_now": "Y" if ready_now_bool else "N",
            "blocked": blocked,
        }
        
        # Handle open position (exit logic)
        if shadow_pos:
            shadow_pos.bars_open += 1
            
            # Shadow exit parameters (deterministic, tight)
            TP_PCT = 0.0030  # 0.30% take profit
            SL_PCT = 0.0020  # 0.20% stop loss
            MAX_HOLD_SECONDS = 3600  # 1 hour max hold
            EXIT_CONF_THRESHOLD = 0.42  # Exit if confidence drops below this
            
            # Check exit conditions (deterministic model - must fire)
            should_exit = False
            exit_reason = ""
            
            # Compute current PnL if price available
            pnl_pct_current = None
            if current_price:
                entry_price = shadow_pos.entry_price
                if shadow_pos.direction == 1:  # long
                    pnl_pct_current = (current_price - entry_price) / entry_price
                else:  # short
                    pnl_pct_current = (entry_price - current_price) / entry_price
            
            # Check ALL exit conditions (any can trigger - not elif chain)
            
            # Exit condition 1: Take Profit
            if pnl_pct_current is not None and pnl_pct_current >= TP_PCT:
                should_exit = True
                exit_reason = f"take_profit_{TP_PCT:.4f}"
            
            # Exit condition 2: Stop Loss
            if not should_exit and pnl_pct_current is not None and pnl_pct_current <= -SL_PCT:
                should_exit = True
                exit_reason = f"stop_loss_{SL_PCT:.4f}"
            
            # Exit condition 3: Time-based timeout (real time, not bars)
            if not should_exit and shadow_pos.entry_ts:
                try:
                    entry_dt = datetime.fromisoformat(shadow_pos.entry_ts.replace("Z", "+00:00"))
                    now_dt = datetime.now(timezone.utc)
                    age_seconds = (now_dt - entry_dt).total_seconds()
                    if age_seconds >= MAX_HOLD_SECONDS:
                        should_exit = True
                        exit_reason = f"timeout_{MAX_HOLD_SECONDS}s"
                except Exception:
                    # Fallback to bars if timestamp parsing fails
                    if shadow_pos.bars_open >= 12:  # ~1 hour at 5-min cadence
                        should_exit = True
                        exit_reason = "timeout_bars_12"
            
            # Exit condition 4: Direction flip (signal says opposite)
            if not should_exit and direction != 0 and direction != shadow_pos.direction:
                should_exit = True
                exit_reason = "direction_flip"
            
            # Exit condition 5: Confidence collapse
            if not should_exit and confidence < EXIT_CONF_THRESHOLD:
                should_exit = True
                exit_reason = f"confidence_drop_{confidence:.3f}"
            
            if should_exit:
                if current_price:
                    entry_price = shadow_pos.entry_price
                    if shadow_pos.direction == 1:
                        pnl_pct = (current_price - entry_price) / entry_price
                    else:
                        pnl_pct = (entry_price - current_price) / entry_price
                else:
                    pnl_pct = None
                
                # Compute USD PnL from shadow notional
                notional_usd = shadow_pos.notional_usd or 0.0
                pnl_usd = notional_usd * pnl_pct if (pnl_pct is not None and notional_usd) else None
                
                event = ShadowEvent(
                    ts=datetime.now(timezone.utc).isoformat(),
                    symbol=symbol,
                    action="would_exit",
                    reason=exit_reason,
                    direction=shadow_pos.direction,
                    entry_price=shadow_pos.entry_price,
                    exit_price=current_price,
                    pnl_pct=pnl_pct,
                    notional_usd=notional_usd,
                    pnl_usd=pnl_usd,
                    **context,
                )
                _log_event(event)
                
                del positions[symbol]
                _save_shadow_state(positions)
            else:
                # Position continues - log would_hold
                event = ShadowEvent(
                    ts=datetime.now(timezone.utc).isoformat(),
                    symbol=symbol,
                    action="would_hold",
                    reason="position_open_no_exit_signal",
                    direction=shadow_pos.direction,
                    confidence=confidence,
                    **context,
                )
                _log_event(event)
                _save_shadow_state(positions)
        else:
            # No position - evaluate entry
            # SHADOW SIMULATION: Evaluate signal conditions separately from gate conditions
            # Shadow answers: "If exploit were allowed, would we have entered/exited?"
            
            # Check signal conditions (entry signal present)
            has_entry_signal = (direction != 0 and current_price is not None and confidence >= 0.50)
            
            # Evaluate gate decision (for logging context)
            would_allow, reason, gate_context = _evaluate_exploit_decision(
                symbol, direction, confidence, current_price
            )
            
            # SHADOW SIMULATION: If signal says "enter", simulate shadow trade even if gate blocks
            if has_entry_signal:
                # Compute shadow notional using position sizer
                # For shadow simulation, use "normal" mode to get sizing (shadow is hypothetical)
                equity_usd = _get_equity_usd()
                notional_usd = 0.0
                try:
                    from engine_alpha.risk.position_sizer import size_notional_usd
                    # Shadow simulation: use "normal" mode for sizing (hypothetical trade)
                    sizing_result = size_notional_usd(
                        symbol=symbol,
                        equity_usd=equity_usd,
                        confidence=confidence,
                        pf_validity=pf_validity,
                        policy_level=policy_level or "reduced",
                        tier=tier,
                        capital_mode="normal",  # Shadow simulates as if normal mode
                        base_risk_bps=10.0,  # 0.10% default
                        max_notional_usd=100.0,
                        min_notional_usd=5.0,
                    )
                    notional_usd = sizing_result.notional_usd
                except Exception:
                    # Fallback to small fixed size if sizing fails
                    notional_usd = 10.0
                
                # Shadow simulation: Open shadow position regardless of gate
                shadow_pos = ShadowPosition(
                    symbol=symbol,
                    direction=direction,
                    entry_price=current_price,
                    entry_ts=datetime.now(timezone.utc).isoformat(),
                    entry_confidence=confidence,
                    bars_open=0,
                    notional_usd=notional_usd,
                )
                positions[symbol] = shadow_pos
                _save_shadow_state(positions)
                
                # Log would_open with shadow simulation context
                if would_allow:
                    event_reason = reason
                    shadow_only = False
                else:
                    event_reason = f"{reason} (shadow_sim)"
                    shadow_only = True
                
                event = ShadowEvent(
                    ts=datetime.now(timezone.utc).isoformat(),
                    symbol=symbol,
                    action="would_open",
                    reason=event_reason,
                    direction=direction,
                    confidence=confidence,
                    entry_price=current_price,
                    notional_usd=notional_usd,
                    shadow_only=shadow_only,
                    blocked_reason=reason if not would_allow else None,
                    **gate_context,
                )
                _log_event(event)
            elif would_allow:
                # Gate allows but no entry signal
                event = ShadowEvent(
                    ts=datetime.now(timezone.utc).isoformat(),
                    symbol=symbol,
                    action="would_hold",
                    reason="gate_allows_no_entry_signal",
                    direction=direction,
                    confidence=confidence,
                    **gate_context,
                )
                _log_event(event)
            else:
                # Would block (no signal, gate blocks)
                event = ShadowEvent(
                    ts=datetime.now(timezone.utc).isoformat(),
                    symbol=symbol,
                    action="would_block",
                    reason=reason,
                    direction=direction,
                    confidence=confidence,
                    **gate_context,
                )
                _log_event(event)
    
    # Update PF snapshot
    _update_pf_snapshot()


def on_bar(
    symbol: str,
    direction: int,
    confidence: float,
    timeframe: str = "15m",
) -> None:
    """
    Process a bar update for shadow exploit lane.
    
    This is called from autonomous_trader.py when exploit decisions are evaluated.
    It does NOT modify any trading behavior - it only observes and logs.
    
    Args:
        symbol: Trading symbol
        direction: Trade direction (1 = long, -1 = short, 0 = flat)
        confidence: Confidence level
        timeframe: Timeframe (default: "15m")
    """
    # Load shadow state
    positions = _load_shadow_state()
    
    # Get current price
    current_price = _get_current_price(symbol, timeframe)
    
    # Check if we have an open shadow position
    shadow_pos = positions.get(symbol)
    
    if shadow_pos:
        # Update bars_open
        shadow_pos.bars_open += 1
        
        # Check exit conditions (simplified - same as real exit logic)
        # Exit on direction flip or confidence drop
        should_exit = False
        exit_reason = ""
        
        if direction != 0 and direction != shadow_pos.direction:
            # Direction flip
            should_exit = True
            exit_reason = "direction_flip"
        elif confidence < 0.42:
            # Confidence drop
            should_exit = True
            exit_reason = "confidence_drop"
        elif shadow_pos.bars_open >= 12:
            # Decay
            should_exit = True
            exit_reason = "decay"
        
        if should_exit:
            if current_price:
                # Compute PnL
                entry_price = shadow_pos.entry_price
                if shadow_pos.direction == 1:  # long
                    pnl_pct = (current_price - entry_price) / entry_price
                else:  # short
                    pnl_pct = (entry_price - current_price) / entry_price
            else:
                pnl_pct = None
            
            # Log exit event
            event = ShadowEvent(
                ts=datetime.now(timezone.utc).isoformat(),
                symbol=symbol,
                action="would_exit",
                reason=exit_reason,
                direction=shadow_pos.direction,
                entry_price=shadow_pos.entry_price,
                exit_price=current_price,
                pnl_pct=pnl_pct,
            )
            _log_event(event)
            
            # Remove position
            del positions[symbol]
            _save_shadow_state(positions)
        else:
            # Update position state
            _save_shadow_state(positions)
    
    # Check if we would open a new position
    if shadow_pos is None:
        # Evaluate exploit gate
        would_allow, reason, context = _evaluate_exploit_decision(
            symbol, direction, confidence, current_price
        )
        
        if would_allow:
            if direction != 0 and current_price:
                # Would open
                shadow_pos = ShadowPosition(
                    symbol=symbol,
                    direction=direction,
                    entry_price=current_price,
                    entry_ts=datetime.now(timezone.utc).isoformat(),
                    entry_confidence=confidence,
                    bars_open=0,
                )
                positions[symbol] = shadow_pos
                _save_shadow_state(positions)
                
                event = ShadowEvent(
                    ts=datetime.now(timezone.utc).isoformat(),
                    symbol=symbol,
                    action="would_open",
                    reason=reason,
                    direction=direction,
                    confidence=confidence,
                    entry_price=current_price,
                    **context,
                )
                _log_event(event)
            else:
                # Gate allows but no entry signal
                event = ShadowEvent(
                    ts=datetime.now(timezone.utc).isoformat(),
                    symbol=symbol,
                    action="would_hold",
                    reason="gate_allows_no_entry_signal",
                    direction=direction,
                    confidence=confidence,
                    **context,
                )
                _log_event(event)
        else:
            # Would block
            event = ShadowEvent(
                ts=datetime.now(timezone.utc).isoformat(),
                symbol=symbol,
                action="would_block",
                reason=reason,
                direction=direction,
                confidence=confidence,
                **context,
            )
            _log_event(event)
    else:
        # Position exists but no exit - log would_hold
        event = ShadowEvent(
            ts=datetime.now(timezone.utc).isoformat(),
            symbol=symbol,
            action="would_hold",
            reason="position_open_no_exit_signal",
            direction=shadow_pos.direction,
            confidence=confidence,
            mode=context.get("mode"),
            policy_level=context.get("policy_level"),
            weight=context.get("weight"),
            ready_now=context.get("ready_now"),
        )
        _log_event(event)
    
    # Update PF snapshot periodically (every call, but lightweight)
    _update_pf_snapshot()


def _update_pf_snapshot() -> None:
    """Update shadow PF snapshot."""
    if not LOG_PATH.exists():
        return
    
    try:
        # Read last 1000 events
        events = []
        with LOG_PATH.open("r", encoding="utf-8") as f:
            lines = f.readlines()
            for line in lines[-1000:]:
                try:
                    events.append(ShadowEvent(**json.loads(line.strip())))
                except Exception:
                    continue
        
        pf_data = _compute_shadow_pf(events)
        pf_data["generated_at"] = datetime.now(timezone.utc).isoformat()
        pf_data["total_events"] = len(events)
        
        _save_json(PF_PATH, pf_data)
    except Exception:
        pass


__all__ = ["on_bar", "evaluate_all_eligible_symbols", "ShadowEvent", "ShadowPosition"]

