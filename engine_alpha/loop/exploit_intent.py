"""
Exploit Intent Generator
------------------------

Single source of truth for computing exploit trading intent (direction, confidence).
Used by both shadow_exploit_lane and exploit_lane_runner.
"""

from __future__ import annotations

from typing import Dict, Any, Optional, Tuple
from engine_alpha.signals.signal_processor import get_signal_vector_live
from engine_alpha.core.confidence_engine import decide


def compute_exploit_intent(
    symbol: str,
    timeframe: str = "15m",
    limit: int = 200,
) -> Dict[str, Any]:
    """
    Compute exploit trading intent for a symbol.
    
    This uses the same signal pipeline as the real trading loop.
    
    Args:
        symbol: Trading symbol (e.g., "SOLUSDT")
        timeframe: Timeframe (default "15m")
        limit: Number of candles to fetch (default 200)
    
    Returns:
        Dict with:
            - direction: int (-1, 0, or +1)
            - confidence: float [0.0, 1.0]
            - entry_ok: bool (direction != 0 and confidence >= 0.50)
            - exit_ok: bool (confidence < 0.42 or direction flip)
            - reason: str (explanation)
            - regime: str (regime name)
            - current_price: Optional[float]
    """
    try:
        # Get signals using the same pipeline as autonomous_trader
        out = get_signal_vector_live(symbol=symbol, timeframe=timeframe, limit=limit)
        
        # Get price-based regime (simplified - use default regime detection)
        # In autonomous_trader, this is computed from price data, but for exploit intent
        # we can use the regime from decide() which will compute it from signals
        decision = decide(out["signal_vector"], out["raw_registry"])
        final = decision.get("final", {})
        regime = decision.get("regime", "unknown")
        
        direction = final.get("dir", 0)
        confidence = final.get("conf", 0.0)
        
        # Get current price from raw_registry if available
        current_price = None
        raw_registry = out.get("raw_registry", {})
        if isinstance(raw_registry, dict):
            # Try to get price from OHLCV data
            ohlcv = raw_registry.get("OHLCV", {})
            if isinstance(ohlcv, dict):
                close = ohlcv.get("close")
                if close is not None:
                    try:
                        current_price = float(close)
                    except Exception:
                        pass
        
        # Determine entry/exit conditions
        entry_ok = (direction != 0 and confidence >= 0.50)
        exit_ok = (confidence < 0.42)  # Simplified exit condition
        
        reason = "signal_ready" if entry_ok else "no_signal"
        if direction == 0:
            reason = "direction_zero"
        elif confidence < 0.50:
            reason = f"confidence_low_{confidence:.2f}"
        
        return {
            "direction": direction,
            "confidence": confidence,
            "entry_ok": entry_ok,
            "exit_ok": exit_ok,
            "reason": reason,
            "regime": regime,
            "current_price": current_price,
            "signal_vector": out.get("signal_vector", {}),
            "raw_registry": raw_registry,
        }
    except Exception as e:
        # Return neutral intent on error
        return {
            "direction": 0,
            "confidence": 0.0,
            "entry_ok": False,
            "exit_ok": False,
            "reason": f"error: {str(e)}",
            "regime": "unknown",
            "current_price": None,
            "signal_vector": {},
            "raw_registry": {},
        }


__all__ = ["compute_exploit_intent"]

