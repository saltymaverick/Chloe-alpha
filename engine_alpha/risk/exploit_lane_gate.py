"""
Exploit Lane Gate (Phase 4l)
-----------------------------

PAPER-only runtime gate for non-exploration (normal) trades.

Prevents normal lane from opening trades when capital policy says "halt/de-risk",
and concentrates normal-lane opens on symbols the allocator marks as lane_intent=exploit
with meaningful weight.

This gate is RESTRICTIVE-ONLY: it can only turn can_open from True to False, never the other way.
"""

from __future__ import annotations

import json
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional, Tuple, Any

from engine_alpha.core.paths import REPORTS

CAPITAL_PROTECTION_PATH = REPORTS / "risk" / "capital_protection.json"
CAPITAL_PLAN_PATH = REPORTS / "risk" / "capital_plan.json"
LIVE_CANDIDATES_PATH = REPORTS / "risk" / "live_candidates.json"
POLICY_PATH = REPORTS / "research" / "exploration_policy_v3.json"
LOG_PATH = REPORTS / "risk" / "exploit_lane_gate_log.jsonl"


@dataclass
class ExploitGateDecision:
    """Decision record for exploit lane gate."""
    symbol: str
    lane: str = "exploit"
    original_can_open: bool = True
    final_can_open: bool = True
    mode: Optional[str] = None
    policy_level: Optional[str] = None
    allow_new_entries: Optional[bool] = None
    lane_intent: Optional[str] = None
    weight: Optional[float] = None
    ready_now: Optional[str] = None
    live_ready: Optional[str] = None
    reason: Optional[str] = None
    ts: str = ""

    def to_dict(self) -> dict:
        return asdict(self)


def _load_json(path: Path) -> dict:
    """Safely load JSON file, return empty dict if missing/invalid."""
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def is_ready_now(val: Any) -> bool:
    """
    Normalize ready_now value to boolean.
    
    Handles:
    - True / False (boolean)
    - "Y" / "N" / "y" / "n" (string)
    - None / missing → False
    
    Returns:
        True if ready_now is True or "Y"/"y", False otherwise
    """
    if val is True:
        return True
    if isinstance(val, str):
        return val.strip().upper() == "Y"
    return False


def _log_decision(decision: ExploitGateDecision) -> None:
    """
    Log gate decision to JSONL file.
    
    Phase 4L+: Log all decisions (both blocks and allows) for audit trail.
    """
    LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
    try:
        with LOG_PATH.open("a", encoding="utf-8") as f:
            f.write(json.dumps(decision.to_dict()) + "\n")
    except Exception:
        pass  # Fail silently on logging errors


def apply_exploit_lane_gate(
    symbol: str,
    can_open: bool,
    *,
    is_paper: bool,
    is_exploration: bool,
) -> Tuple[bool, Optional[ExploitGateDecision]]:
    """
    Apply exploit lane gate to normal-lane trade opens.
    
    Args:
        symbol: Symbol to check
        can_open: Current can_open status (from previous gates)
        is_paper: Whether in PAPER mode
        is_exploration: Whether this is an exploration trade
    
    Returns:
        Tuple of (final_can_open, decision_record)
        decision_record is None if gate didn't apply or didn't block
    """
    # Rule 1: If not paper → return unchanged (no-op)
    if not is_paper:
        return can_open, None
    
    # Rule 2: If is_exploration=True → return unchanged (this gate is normal lane only)
    if is_exploration:
        return can_open, None
    
    # Rule 3: Load reports (safe on missing files/fields)
    capital_protection = _load_json(CAPITAL_PROTECTION_PATH)
    capital_plan = _load_json(CAPITAL_PLAN_PATH)
    live_candidates = _load_json(LIVE_CANDIDATES_PATH)
    policy = _load_json(POLICY_PATH)
    
    # Extract global mode from capital protection
    global_mode_data = capital_protection.get("global", {})
    mode = global_mode_data.get("mode")
    
    # Extract symbol data from capital plan
    symbols_plan = capital_plan.get("symbols", {})
    symbol_entry = symbols_plan.get(symbol, {})
    lane_intent = symbol_entry.get("lane_intent")
    weight = symbol_entry.get("weight")
    
    # Extract symbol data from live candidates
    symbols_lc = live_candidates.get("symbols", {})
    symbol_lc = symbols_lc.get(symbol, {})
    ready_now_raw = symbol_lc.get("ready_now") or symbol_lc.get("ReadyNow") or symbol_lc.get("ready")
    live_ready_raw = symbol_lc.get("live_ready")
    
    # Normalize ready_now using helper (defensive, backward compatible)
    ready_now_bool = is_ready_now(ready_now_raw)
    ready_now = "Y" if ready_now_bool else "N"
    
    # Normalize live_ready similarly
    live_ready_bool = is_ready_now(live_ready_raw)
    live_ready = "Y" if live_ready_bool else "N"
    
    # Extract policy level
    symbols_policy = policy.get("symbols", {})
    symbol_policy = symbols_policy.get(symbol, {})
    policy_level = symbol_policy.get("level")
    allow_new_entries = symbol_policy.get("allow_new_entries", True)
    
    # Create decision record
    decision = ExploitGateDecision(
        symbol=symbol,
        original_can_open=can_open,
        final_can_open=can_open,
        mode=mode,
        policy_level=policy_level,
        allow_new_entries=allow_new_entries,
        lane_intent=lane_intent,
        weight=weight,
        ready_now=ready_now,
        live_ready=live_ready,
        ts=datetime.now(timezone.utc).isoformat(),
    )
    
    # Rule 4: Hard blocks (strict capital_mode behavior - Phase 4L+)
    
    # halt_new_entries: BLOCK all exploit opens
    if mode == "halt_new_entries":
        decision.final_can_open = False
        decision.reason = f"CapitalProtection=halt_new_entries: halt all exploit opens"
        _log_decision(decision)
        return False, decision
    
    # Policy blocks
    if policy_level == "blocked" or allow_new_entries is False:
        decision.final_can_open = False
        decision.reason = f"Policy blocked: level={policy_level}, allow_new_entries={allow_new_entries}"
        _log_decision(decision)
        return False, decision
    
    # Lane intent must be exploit
    if lane_intent != "exploit":
        decision.final_can_open = False
        decision.reason = f"Lane intent mismatch: lane_intent={lane_intent} (expected 'exploit')"
        _log_decision(decision)
        return False, decision
    
    # Phase 5f: de_risk mode with smoothed weight gating
    if mode == "de_risk":
        if not ready_now_bool:
            decision.final_can_open = False
            decision.reason = f"de_risk mode: not ready_now (need ready_now=Y)"
            _log_decision(decision)
            return False, decision
        
        # Check if symbol is rank #1 by capital weight
        # Load all symbols and find top weight
        all_weights = []
        for sym, entry in symbols_plan.items():
            w = entry.get("weight", 0.0)
            if w is not None:
                all_weights.append((sym, w))
        
        if not all_weights:
            decision.final_can_open = False
            decision.reason = "de_risk mode: no weights found"
            _log_decision(decision)
            return False, decision
        
        all_weights.sort(key=lambda x: x[1], reverse=True)
        top_symbol, top_weight = all_weights[0]
        
        if symbol != top_symbol:
            decision.final_can_open = False
            decision.reason = f"de_risk mode: not rank #1 (top={top_symbol}, weight={top_weight:.3f})"
            _log_decision(decision)
            return False, decision
        
        # Phase 5f: Compute smoothed weight (simple EMA-like smoothing)
        # Use max of raw weight and 95% of top weight to handle numerical noise
        smoothed_weight = max(weight or 0.0, top_weight * 0.95)
        effective_weight = smoothed_weight
        
        # Phase 5f: Mode-aware thresholds
        min_weight = 0.18 if mode == "de_risk" else 0.20
        
        if effective_weight < min_weight:
            decision.final_can_open = False
            decision.reason = f"de_risk mode: effective_weight={effective_weight:.3f} < {min_weight} (raw={weight:.3f}, smoothed={smoothed_weight:.3f})"
            _log_decision(decision)
            return False, decision
        
        # Passed de_risk checks
        decision.reason = f"de_risk mode: passed (rank #1, ready_now=Y, effective_weight={effective_weight:.3f}, raw={weight:.3f})"
        return can_open, decision
    
    # Phase 5f: normal mode with smoothed weight gating
    if mode == "normal":
        # Phase 5f: Compute smoothed weight for normal mode too
        all_weights = []
        for sym, entry in symbols_plan.items():
            w = entry.get("weight", 0.0)
            if w is not None:
                all_weights.append((sym, w))
        
        if all_weights:
            all_weights.sort(key=lambda x: x[1], reverse=True)
            top_weight = all_weights[0][1] if all_weights else 0.0
            smoothed_weight = max(weight or 0.0, top_weight * 0.95)
            effective_weight = smoothed_weight
        else:
            effective_weight = weight or 0.0
        
        # Phase 5f: Mode-aware thresholds
        min_weight = 0.20 if mode == "normal" else 0.18
        
        if effective_weight < min_weight:
            decision.final_can_open = False
            decision.reason = f"Weight too low: effective_weight={effective_weight:.3f} < {min_weight} (raw={weight:.3f})"
            _log_decision(decision)
            return False, decision
        
        # Soft safety filter: ready_now check
        if not ready_now_bool:
            if weight is None or weight < 0.20:
                decision.final_can_open = False
                decision.reason = f"Not ready_now: ready_now={ready_now}, weight={weight} (need weight>=0.20 to override)"
                _log_decision(decision)
                return False, decision
        
        # Gate passed
        decision.reason = f"normal mode: passed (lane_intent=exploit, weight={weight:.3f}, ready_now={ready_now})"
        return can_open, decision
    
    # Unknown mode: block for safety
    decision.final_can_open = False
    decision.reason = f"Unknown capital mode: mode={mode} (blocking for safety)"
    _log_decision(decision)
    return False, decision


__all__ = ["apply_exploit_lane_gate", "ExploitGateDecision", "is_ready_now"]
