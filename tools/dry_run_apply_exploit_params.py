"""
Dry-Run Apply Exploit Params
-----------------------------

Preview and optionally apply exploit parameter proposals.

Safety:
- Shows diff preview by default
- Only applies if --apply --i-understand flags provided
- Validates all constraints before applying
"""

from __future__ import annotations

import json
import sys
import argparse
from pathlib import Path
from typing import Dict, Any

ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT))

from engine_alpha.core.paths import CONFIG, REPORTS

PROPOSALS_PATH = REPORTS / "evolver" / "exploit_param_proposals.json"
EXPLOIT_PARAMS_PATH = CONFIG / "exploit_params.json"


def _load_json(path: Path) -> Dict[str, Any]:
    """Safely load JSON file."""
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def _save_json(path: Path, data: Dict[str, Any]) -> None:
    """Safely save JSON file."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)


def _get_nested_value(data: Dict[str, Any], path: str) -> Any:
    """Get nested value by dot-separated path."""
    parts = path.split(".")
    current = data
    for part in parts:
        if isinstance(current, dict):
            current = current.get(part)
        else:
            return None
    return current


def _set_nested_value(data: Dict[str, Any], path: str, value: Any) -> None:
    """Set nested value by dot-separated path."""
    parts = path.split(".")
    current = data
    for i, part in enumerate(parts[:-1]):
        if part not in current:
            current[part] = {}
        current = current[part]
    current[parts[-1]] = value


def _validate_proposal(proposal: Dict[str, Any], current_params: Dict[str, Any]) -> tuple[bool, str]:
    """Validate a proposal against constraints."""
    param_path = proposal.get("param_path", "")
    proposed_value = proposal.get("proposed_value")
    
    if not param_path or proposed_value is None:
        return False, "Missing param_path or proposed_value"
    
    # Get param definition
    parts = param_path.split(".")
    if len(parts) < 3:
        return False, f"Invalid param_path format: {param_path}"
    
    category = parts[0]
    param_name = parts[1]
    
    params_def = current_params.get("params", {})
    category_def = params_def.get(category, {})
    param_def = category_def.get(param_name, {})
    
    if not param_def:
        return False, f"Parameter not found: {param_path}"
    
    # Check bounds
    min_val = param_def.get("min")
    max_val = param_def.get("max")
    
    if min_val is not None and proposed_value < min_val:
        return False, f"Proposed value {proposed_value} < min {min_val}"
    
    if max_val is not None and proposed_value > max_val:
        return False, f"Proposed value {proposed_value} > max {max_val}"
    
    return True, "ok"


def print_diff(proposals: List[Dict[str, Any]], current_params: Dict[str, Any]) -> None:
    """Print diff preview."""
    print("EXPLOIT PARAM PROPOSALS - DIFF PREVIEW")
    print("=" * 80)
    print()
    
    if not proposals:
        print("No proposals to apply.")
        print()
        return
    
    print(f"Found {len(proposals)} proposal(s):")
    print()
    
    for i, proposal in enumerate(proposals, 1):
        param_path = proposal.get("param_path", "")
        current_value = _get_nested_value(current_params, f"params.{param_path}")
        proposed_value = proposal.get("proposed_value")
        reason = proposal.get("reason", "")
        risk_impact = proposal.get("risk_impact", "unknown")
        
        print(f"[{i}] {param_path}")
        print(f"     Current:  {current_value}")
        print(f"     Proposed: {proposed_value}")
        print(f"     Change:   {proposed_value - current_value:+.3f}")
        print(f"     Reason:   {reason}")
        print(f"     Risk:     {risk_impact}")
        print()
    
    print("=" * 80)
    print()
    print("To apply these changes, run:")
    print("  python3 -m tools.dry_run_apply_exploit_params --apply --i-understand")
    print()


def apply_proposals(proposals: List[Dict[str, Any]], current_params: Dict[str, Any]) -> tuple[bool, str]:
    """Apply proposals to config."""
    # Validate all proposals
    for proposal in proposals:
        valid, reason = _validate_proposal(proposal, current_params)
        if not valid:
            return False, f"Invalid proposal: {reason}"
    
    # Apply each proposal
    for proposal in proposals:
        param_path = proposal.get("param_path", "")
        proposed_value = proposal.get("proposed_value")
        _set_nested_value(current_params, f"params.{param_path}", proposed_value)
    
    # Update metadata
    current_params["meta"]["last_modified"] = datetime.now(timezone.utc).isoformat()
    current_params["meta"]["proposal_count"] = current_params["meta"].get("proposal_count", 0) + len(proposals)
    
    # Save
    _save_json(EXPLOIT_PARAMS_PATH, current_params)
    
    return True, f"Applied {len(proposals)} proposal(s)"


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Dry-run apply exploit parameter proposals")
    parser.add_argument("--apply", action="store_true", help="Actually apply proposals")
    parser.add_argument("--i-understand", action="store_true", help="Confirm you understand the risks")
    
    args = parser.parse_args()
    
    # Load proposals
    proposals_data = _load_json(PROPOSALS_PATH)
    proposals = proposals_data.get("proposals", [])
    
    # Load current params
    current_params = _load_json(EXPLOIT_PARAMS_PATH)
    
    if not current_params:
        print("ERROR: exploit_params.json not found")
        return 1
    
    # Print diff preview
    print_diff(proposals, current_params)
    
    # Apply if requested
    if args.apply:
        if not args.i_understand:
            print("ERROR: --apply requires --i-understand flag")
            print("This is a safety measure to prevent accidental changes.")
            return 1
        
        success, message = apply_proposals(proposals, current_params)
        if success:
            print(f"✓ {message}")
            return 0
        else:
            print(f"✗ {message}")
            return 1
    
    return 0


if __name__ == "__main__":
    from datetime import datetime, timezone
    sys.exit(main())

