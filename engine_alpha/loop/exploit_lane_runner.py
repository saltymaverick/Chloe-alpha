"""
Exploit Lane Runner (Phase 5c)
-------------------------------

Main runner for micro-paper exploit trades.

Reads:
- capital_plan (weights + lane_intent)
- capital_protection (mode)
- live_candidates (ready_now)
- exploit_lane_gate decision
- PF validity
- Exploration policy

Places PAPER exploit trades only when:
- ENABLE_MICRO_PAPER_EXPLOIT=true env flag
- All hard gates pass
- Position sizer approves

Safety:
- PAPER-only
- Restrictive-only
- No config mutation
"""

from __future__ import annotations

import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any, Optional

from engine_alpha.core.paths import REPORTS
from engine_alpha.risk.exploit_lane_gate import apply_exploit_lane_gate
from engine_alpha.risk.position_sizer import size_notional_usd
from engine_alpha.loop.exploit_executor_paper import (
    can_open_exploit_trade,
    open_exploit_trade,
    close_exploit_trade,
    get_open_positions,
)
from engine_alpha.data.live_prices import get_live_ohlcv
from engine_alpha.signals.signal_processor import get_signal_vector
from engine_alpha.core.confidence_engine import decide

# Paths
CAPITAL_PLAN_PATH = REPORTS / "risk" / "capital_plan.json"
CAPITAL_PROTECTION_PATH = REPORTS / "risk" / "capital_protection.json"
LIVE_CANDIDATES_PATH = REPORTS / "risk" / "live_candidates.json"
POLICY_PATH = REPORTS / "research" / "exploration_policy_v3.json"
PF_VALIDITY_PATH = REPORTS / "risk" / "pf_validity.json"
PF_PATH = REPORTS / "exploit" / "exploit_pf.json"
PROMOTION_GATE_PATH = REPORTS / "loop" / "promotion_gate.json"

# Env flag
ENABLE_MICRO_PAPER_EXPLOIT = os.getenv("ENABLE_MICRO_PAPER_EXPLOIT", "false").lower() == "true"


def _load_json(path: Path) -> Dict[str, Any]:
    """Safely load JSON file."""
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def _get_equity_usd() -> float:
    """Get current equity in USD from config."""
    try:
        import yaml
        from engine_alpha.core.paths import CONFIG
        defaults = {"start_equity": 10000.0}
        cfg_path = CONFIG / "risk.yaml"
        if not cfg_path.exists():
            return defaults["start_equity"]
        data = yaml.safe_load(cfg_path.read_text()) or {}
        accounting = data.get("accounting", {})
        return float(accounting.get("start_equity", defaults["start_equity"]))
    except Exception:
        return 10000.0


def _update_pf_snapshot() -> None:
    """Update exploit PF snapshot."""
    try:
        from engine_alpha.reflect.shadow_exploit_lane import _compute_shadow_pf, ShadowEvent
        from engine_alpha.loop.exploit_executor_paper import TRADES_LOG_PATH
        
        if not TRADES_LOG_PATH.exists():
            return
        
        # Read trades
        events = []
        with TRADES_LOG_PATH.open("r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    data = json.loads(line)
                    if data.get("event") == "close":
                        # Convert to ShadowEvent-like structure
                        event = ShadowEvent(
                            ts=data.get("ts", ""),
                            symbol=data.get("symbol", ""),
                            action="would_exit",
                            reason=data.get("reason", ""),
                            pnl_pct=data.get("pnl_pct"),
                            pnl_usd=data.get("pnl_usd"),
                        )
                        events.append(event)
                except Exception:
                    continue
        
        pf_data = _compute_shadow_pf(events)
        pf_data["generated_at"] = datetime.now(timezone.utc).isoformat()
        
        PF_PATH.parent.mkdir(parents=True, exist_ok=True)
        with PF_PATH.open("w", encoding="utf-8") as f:
            json.dump(pf_data, f, indent=2)
    except Exception:
        pass


def run_exploit_lane() -> Dict[str, Any]:
    """
    Run exploit lane evaluation and place trades if allowed.
    
    Returns:
        Dict with summary of actions taken
    """
    # Check exploit arming state (Phase 5d) - executor only trusts exploit_arming.json
    ARMING_STATE_PATH = REPORTS / "loop" / "exploit_arming.json"
    exploit_armed = False
    arming_state = {}
    
    if ARMING_STATE_PATH.exists():
        try:
            arming_state = _load_json(ARMING_STATE_PATH)
            exploit_armed = arming_state.get("armed", False)
        except Exception:
            exploit_armed = False
    
    if not exploit_armed:
        disarm_reason = arming_state.get("disarm_reason", "exploit_not_armed")
        return {
            "enabled": False,
            "armed": False,
            "reason": disarm_reason,
            "capital_mode": arming_state.get("capital_mode", "unknown"),
            "actions": [],
        }
    
    # Phase: Promotion Gate - check if exploit opens are allowed
    promotion_gate = _load_json(PROMOTION_GATE_PATH)
    promotion_mode = promotion_gate.get("mode", "DISABLED")
    
    if promotion_mode != "EXPLOIT_ENABLED":
        # Block new opens, but allow exits
        return {
            "enabled": False,
            "armed": True,  # Armed but blocked by promotion gate
            "reason": f"promotion_gate_mode={promotion_mode}",
            "capital_mode": arming_state.get("capital_mode", "unknown"),
            "actions": [],  # No new opens allowed
        }
    
    # Load all inputs
    capital_plan = _load_json(CAPITAL_PLAN_PATH)
    capital_protection = _load_json(CAPITAL_PROTECTION_PATH)
    live_candidates = _load_json(LIVE_CANDIDATES_PATH)
    policy = _load_json(POLICY_PATH)
    pf_validity = _load_json(PF_VALIDITY_PATH)
    
    # Extract capital mode (same way as everywhere else)
    capital_mode = capital_protection.get("mode")
    if not capital_mode:
        global_mode = capital_protection.get("global", {})
        capital_mode = global_mode.get("mode", "unknown")
    
    # Get arming state for return value
    arming_state = _load_json(ARMING_STATE_PATH)
    
    # Get all exploit-intent symbols
    symbols_plan = capital_plan.get("symbols", {})
    exploit_symbols = []
    for sym, plan_data in symbols_plan.items():
        if plan_data.get("lane_intent") == "exploit":
            weight = plan_data.get("weight", 0.0)
            exploit_symbols.append((sym, weight, plan_data))
    
    # Sort by weight (descending)
    exploit_symbols.sort(key=lambda x: x[1], reverse=True)
    
    actions = []
    
    # Check open positions for exits
    open_positions = get_open_positions()
    for symbol, position in list(open_positions.items()):
        # Get exploit intent using shared pipeline
        try:
            from engine_alpha.loop.exploit_intent import compute_exploit_intent
            intent = compute_exploit_intent(symbol=symbol, timeframe="15m")
            direction = intent.get("direction", 0)
            confidence = intent.get("confidence", 0.0)
        except Exception:
            direction = 0
            confidence = 0.0
        
        # Check exit conditions
        should_exit = False
        exit_reason = ""
        
        if direction != 0 and direction != position.direction:
            should_exit = True
            exit_reason = "direction_flip"
        elif confidence < 0.42:
            should_exit = True
            exit_reason = "confidence_drop"
        
        if should_exit:
            current_price = None
            try:
                rows = get_live_ohlcv(symbol, "15m", limit=1)
                if rows:
                    current_price = float(rows[-1].get("close", 0))
            except Exception:
                pass
            
            if current_price:
                success, pnl_usd, reason = close_exploit_trade(symbol, current_price, exit_reason)
                if success:
                    actions.append({
                        "action": "closed",
                        "symbol": symbol,
                        "reason": exit_reason,
                        "pnl_usd": pnl_usd,
                    })
    
    # Check for new entries (only if no open positions)
    if len(open_positions) == 0 and exploit_symbols:
        # Try top symbol
        symbol, weight, plan_data = exploit_symbols[0]
        
        # Get exploit intent using shared pipeline
        try:
            from engine_alpha.loop.exploit_intent import compute_exploit_intent
            intent = compute_exploit_intent(symbol=symbol, timeframe="15m")
            direction = intent.get("direction", 0)
            confidence = intent.get("confidence", 0.0)
        except Exception:
            direction = 0
            confidence = 0.0
        
        if direction != 0:
            # Get symbol data
            symbols_lc = live_candidates.get("symbols", {})
            symbol_lc = symbols_lc.get(symbol, {})
            
            symbols_policy = policy.get("symbols", {})
            symbol_policy = symbols_policy.get(symbol, {})
            policy_level = symbol_policy.get("level")
            
            validity_entry = pf_validity.get("by_symbol", {}).get(symbol, {})
            pf_validity_score = validity_entry.get("validity_score", 0.5)
            
            tier = plan_data.get("tier", "tier3")
            
            # Phase 5g: Check quarantine (blocks new entries, never blocks exits)
            quarantine_blocked = False
            try:
                from engine_alpha.core.paths import REPORTS as REPORTS_PATH
                quarantine_path = REPORTS_PATH / "risk" / "quarantine.json"
                if quarantine_path.exists():
                    quarantine = _load_json(quarantine_path)
                    if quarantine.get("enabled", False):
                        blocked_symbols = quarantine.get("blocked_symbols", [])
                        if symbol in blocked_symbols:
                            quarantine_blocked = True
            except Exception:
                # Fail-safe: if quarantine check fails, allow (don't block on error)
                pass
            
            if quarantine_blocked:
                actions.append({
                    "action": "blocked",
                    "symbol": symbol,
                    "reason": "quarantine",
                })
            else:
                # Apply exploit gate
                gate_decision, gate_reason = apply_exploit_lane_gate(
                    symbol=symbol,
                    capital_plan=capital_plan,
                    capital_protection=capital_protection,
                    live_candidates=live_candidates,
                    policy=policy,
                )
                
                if gate_decision:
                    # Check executor can open
                    can_open, executor_reason = can_open_exploit_trade(symbol, capital_mode)
                    
                    if can_open:
                        # Size position
                        equity_usd = _get_equity_usd()
                        sizing_result = size_notional_usd(
                            symbol=symbol,
                            equity_usd=equity_usd,
                            confidence=confidence,
                            pf_validity=pf_validity_score,
                            policy_level=policy_level or "reduced",
                            tier=tier,
                            capital_mode=capital_mode,
                            base_risk_bps=10.0,
                            max_notional_usd=100.0,
                            min_notional_usd=5.0,
                        )
                        
                        if sizing_result.notional_usd > 0:
                            # Get current price
                            current_price = None
                            try:
                                rows = get_live_ohlcv(symbol, "15m", limit=1)
                                if rows:
                                    current_price = float(rows[-1].get("close", 0))
                            except Exception:
                                pass
                            
                            if current_price:
                                # Open trade
                                success, reason = open_exploit_trade(
                                    symbol=symbol,
                                    direction=direction,
                                    entry_price=current_price,
                                    notional_usd=sizing_result.notional_usd,
                                    confidence=confidence,
                                )
                                
                                if success:
                                    actions.append({
                                        "action": "opened",
                                        "symbol": symbol,
                                        "direction": direction,
                                        "notional_usd": sizing_result.notional_usd,
                                        "confidence": confidence,
                                    })
                                else:
                                    actions.append({
                                        "action": "blocked",
                                        "symbol": symbol,
                                        "reason": reason,
                                    })
                            else:
                                actions.append({
                                    "action": "blocked",
                                    "symbol": symbol,
                                    "reason": "no_price",
                                })
                        else:
                            actions.append({
                                "action": "blocked",
                                "symbol": symbol,
                                "reason": sizing_result.reason,
                            })
                    else:
                        actions.append({
                            "action": "blocked",
                            "symbol": symbol,
                            "reason": executor_reason,
                        })
                else:
                    actions.append({
                        "action": "blocked",
                        "symbol": symbol,
                        "reason": gate_reason,
                    })
    
    # Update PF snapshot
    _update_pf_snapshot()
    
    return {
        "enabled": True,
        "armed": True,
        "capital_mode": capital_mode,
        "actions": actions,
    }


__all__ = ["run_exploit_lane"]

