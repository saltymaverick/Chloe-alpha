"""
Exploit Parameter Mutator (GPT-Guided)
---------------------------------------

Reads shadow exploit scores and proposes parameter adjustments.
Proposal-only: never auto-applies changes.

Safety:
- PAPER-only
- Proposal-only (requires explicit apply)
- Respects capital mode constraints
- Never increases risk in de_risk/halt modes
"""

from __future__ import annotations

import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any, List, Optional

from engine_alpha.core.paths import REPORTS, CONFIG

# Paths
SHADOW_SCORES_PATH = REPORTS / "reflect" / "shadow_exploit_scores.json"
PF_VALIDITY_PATH = REPORTS / "risk" / "pf_validity.json"
CAPITAL_PROTECTION_PATH = REPORTS / "risk" / "capital_protection.json"
EXPLOIT_PARAMS_PATH = CONFIG / "exploit_params.json"
PROMPT_TEMPLATE_PATH = CONFIG / "prompts" / "exploit_param_mutation.txt"
PROPOSALS_PATH = REPORTS / "evolver" / "exploit_param_proposals.json"
PROPOSALS_HISTORY_PATH = REPORTS / "evolver" / "exploit_param_proposals.jsonl"


def _load_json(path: Path) -> Dict[str, Any]:
    """Safely load JSON file."""
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def _load_text(path: Path) -> str:
    """Safely load text file."""
    if not path.exists():
        return ""
    try:
        return path.read_text(encoding="utf-8")
    except Exception:
        return ""


def _save_json(path: Path, data: Dict[str, Any]) -> None:
    """Safely save JSON file."""
    path.parent.mkdir(parents=True, exist_ok=True)
    try:
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    except Exception:
        pass


def _append_jsonl(path: Path, data: Dict[str, Any]) -> None:
    """Append JSON line to file."""
    path.parent.mkdir(parents=True, exist_ok=True)
    try:
        with path.open("a", encoding="utf-8") as f:
            f.write(json.dumps(data) + "\n")
    except Exception:
        pass


def _summarize_shadow_scores(scores: Dict[str, Any]) -> str:
    """Create summary of shadow exploit scores."""
    global_scores = scores.get("global", {})
    pf_7d = global_scores.get("pf_7d")
    pf_30d = global_scores.get("pf_30d")
    trades_7d = global_scores.get("trades_7d", 0)
    trades_30d = global_scores.get("trades_30d", 0)
    win_rate = global_scores.get("win_rate", 0.0)
    max_dd = global_scores.get("max_drawdown_pct", 0.0)
    
    pf7_str = f"{pf_7d:.3f}" if pf_7d else "N/A"
    pf30_str = f"{pf_30d:.3f}" if pf_30d else "N/A"
    
    return (
        f"PF_7D={pf7_str}, PF_30D={pf30_str}, "
        f"Trades_7D={trades_7d}, Trades_30D={trades_30d}, "
        f"WinRate={win_rate:.1%}, MaxDD={max_dd:.2f}%"
    )


def _summarize_pf_validity(validity: Dict[str, Any]) -> str:
    """Create summary of PF validity."""
    by_symbol = validity.get("by_symbol", {})
    if not by_symbol:
        return "No validity data"
    
    avg_validity = 0.0
    count = 0
    for sym, entry in by_symbol.items():
        score = entry.get("validity_score", 0.0)
        if score:
            avg_validity += score
            count += 1
    
    if count > 0:
        avg_validity /= count
        return f"Avg validity={avg_validity:.3f} (n={count})"
    return "No validity scores"


def _call_gpt(prompt: str) -> Optional[Dict[str, Any]]:
    """
    Call GPT API to generate proposals.
    
    Returns:
        Parsed JSON response or None if failed
    """
    # Check if GPT is enabled
    use_gpt = os.getenv("USE_GPT_REFLECTION", "false").lower() == "true"
    if not use_gpt:
        return None
    
    try:
        from engine_alpha.reflect.gpt_reflection import call_gpt_api
        
        response = call_gpt_api(
            system_prompt="You are a quant risk engineer. Output only valid JSON.",
            user_prompt=prompt,
            model="gpt-4",
            temperature=0.3,
        )
        
        if response:
            # Try to extract JSON from response
            response_text = response if isinstance(response, str) else str(response)
            
            # Find JSON block
            start_idx = response_text.find("{")
            end_idx = response_text.rfind("}") + 1
            
            if start_idx >= 0 and end_idx > start_idx:
                json_str = response_text[start_idx:end_idx]
                return json.loads(json_str)
    except Exception:
        pass
    
    return None


def generate_proposals() -> Dict[str, Any]:
    """
    Generate exploit parameter mutation proposals.
    
    Returns:
        Dict with proposals and metadata
    """
    # Load inputs
    shadow_scores = _load_json(SHADOW_SCORES_PATH)
    pf_validity = _load_json(PF_VALIDITY_PATH)
    capital_protection = _load_json(CAPITAL_PROTECTION_PATH)
    exploit_params = _load_json(EXPLOIT_PARAMS_PATH)
    prompt_template = _load_text(PROMPT_TEMPLATE_PATH)
    
    # Extract capital mode
    global_mode = capital_protection.get("global", {})
    capital_mode = global_mode.get("mode", "unknown")
    
    # Create summaries
    shadow_summary = _summarize_shadow_scores(shadow_scores)
    validity_summary = _summarize_pf_validity(pf_validity)
    
    # Format current params for prompt
    current_params_str = json.dumps(exploit_params.get("params", {}), indent=2)
    
    # Build prompt
    if prompt_template:
        prompt = prompt_template.format(
            shadow_scores_summary=shadow_summary,
            pf_validity_summary=validity_summary,
            capital_mode=capital_mode,
            current_params=current_params_str,
        )
    else:
        # Fallback prompt
        prompt = f"""
Analyze exploit lane performance and propose parameter adjustments.

Shadow Scores: {shadow_summary}
PF Validity: {validity_summary}
Capital Mode: {capital_mode}
Current Params: {current_params_str}

Output JSON with proposals array. Never increase risk if capital_mode != "normal".
"""
    
    # Call GPT (if enabled)
    proposals_data = _call_gpt(prompt)
    
    if not proposals_data:
        # Fallback: no proposals (GPT not enabled or failed)
        proposals_data = {
            "proposals": [],
            "summary": "No proposals generated (GPT not enabled or no safe improvements identified)",
            "risk_checks": [],
        }
    
    # Add metadata
    result = {
        "engine": "exploit_param_mutator_v1",
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "capital_mode": capital_mode,
        "shadow_scores_summary": shadow_summary,
        "pf_validity_summary": validity_summary,
        **proposals_data,
    }
    
    # Save proposals
    _save_json(PROPOSALS_PATH, result)
    
    # Append to history
    _append_jsonl(PROPOSALS_HISTORY_PATH, result)
    
    return result


__all__ = ["generate_proposals"]

