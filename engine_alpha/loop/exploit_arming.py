"""
Exploit Auto-Arming Engine (Phase 5d)
--------------------------------------

Automatically arms/disarms exploit execution based on objective readiness signals.

Safety:
- PAPER-only
- Restrictive-only (never enables live trading)
- Fail-safe: exceptions → armed=false
- Operator-controlled: respects ENABLE_MICRO_PAPER_EXPLOIT env flag
- Hysteresis-based: requires consecutive OK ticks before arming
- Instant disarms: no hysteresis on safety disarms

Design Intent:
- Think like a risk committee
- Never surprise the operator
- Fail closed
- Promote gradually
- Disarm instantly
"""

from __future__ import annotations

import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple

from engine_alpha.core.paths import REPORTS

# Paths
ARMING_STATE_PATH = REPORTS / "loop" / "exploit_arming.json"
CAPITAL_PROTECTION_PATH = REPORTS / "risk" / "capital_protection.json"
CAPITAL_PLAN_PATH = REPORTS / "risk" / "capital_plan.json"
LIVE_CANDIDATES_PATH = REPORTS / "risk" / "live_candidates.json"
SHADOW_SCORES_PATH = REPORTS / "reflect" / "shadow_exploit_scores.json"
EXECUTION_QUALITY_PATH = REPORTS / "research" / "execution_quality.json"
POLICY_PATH = REPORTS / "research" / "exploration_policy_v3.json"
PROMOTION_GATE_PATH = REPORTS / "loop" / "promotion_gate.json"

# Constants
REQUIRED_CONSECUTIVE_OK_TICKS = 6
MIN_SHADOW_TRADES_7D = 8
MIN_SHADOW_TRADES_30D = 20
MAX_SHADOW_MDD_PCT = 6.0
MIN_SHADOW_PF_7D = 1.05
MIN_SHADOW_PF_30D = 1.03
MIN_CAPITAL_WEIGHT = 0.15


def _load_json(path: Path) -> Dict[str, Any]:
    """Safely load JSON file."""
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}


def _get(obj: Dict[str, Any], *keys: str, default: Any = None) -> Any:
    """Safely descend nested dicts."""
    current = obj
    for key in keys:
        if not isinstance(current, dict):
            return default
        current = current.get(key)
        if current is None:
            return default
    return current


def _is_ready_now(val: Any) -> bool:
    """Normalize ready_now value to bool."""
    if isinstance(val, bool):
        return val
    if isinstance(val, str):
        return val.upper() in ("Y", "YES", "TRUE", "1")
    return False


def _check_hard_safety_disarms(
    capital_mode: str,
    operator_enabled: bool,
    eligible_count: int,
    shadow_scores: Dict[str, Any],
    exploit_symbols: List[str],
) -> Tuple[bool, Optional[str]]:
    """
    Check hard safety disarms (instant, no hysteresis).
    
    Returns:
        (should_disarm, reason)
    """
    # 1. Capital mode check
    if capital_mode != "normal":
        return True, f"capital_mode={capital_mode}"
    
    # 2. Operator flag check
    if not operator_enabled:
        return True, "operator_disabled"
    
    # 3. Eligible symbols check
    if eligible_count == 0:
        return True, "no_eligible_symbols"
    
    # 4. Shadow sample size check
    global_metrics = shadow_scores.get("global", {})
    trades_7d = global_metrics.get("trades_7d", 0)
    trades_30d = global_metrics.get("trades_30d", 0)
    
    if trades_7d < MIN_SHADOW_TRADES_7D:
        return True, f"shadow_trades_7d={trades_7d}<{MIN_SHADOW_TRADES_7D}"
    
    if trades_30d < MIN_SHADOW_TRADES_30D:
        return True, f"shadow_trades_30d={trades_30d}<{MIN_SHADOW_TRADES_30D}"
    
    # 5. Shadow MDD check (per exploit symbol)
    by_symbol = shadow_scores.get("by_symbol", {})
    for symbol in exploit_symbols:
        symbol_data = by_symbol.get(symbol, {})
        mdd = symbol_data.get("max_drawdown_pct", 0.0)
        if mdd > MAX_SHADOW_MDD_PCT:
            return True, f"{symbol}_mdd={mdd:.2f}%>{MAX_SHADOW_MDD_PCT}%"
    
    return False, None


def _check_arming_conditions(
    capital_mode: str,
    operator_enabled: bool,
    eligible_symbols: List[str],
    shadow_scores: Dict[str, Any],
    execution_quality: Dict[str, Any],
) -> Tuple[bool, List[str]]:
    """
    Check arming conditions (ALL required).
    
    Returns:
        (all_conditions_met, reasons)
    """
    reasons = []
    
    # 1. Capital mode
    if capital_mode != "normal":
        reasons.append(f"capital_mode={capital_mode}")
        return False, reasons
    
    # 2. Operator flag
    if not operator_enabled:
        reasons.append("operator_disabled")
        return False, reasons
    
    # 3. Eligible symbols
    if not eligible_symbols:
        reasons.append("no_eligible_symbols")
        return False, reasons
    
    # 4. Shadow PF (use pf_display only)
    global_metrics = shadow_scores.get("global", {})
    pf_7d = global_metrics.get("pf_7d_display") or global_metrics.get("pf_7d")
    pf_30d = global_metrics.get("pf_30d_display") or global_metrics.get("pf_30d")
    
    if pf_7d is None or pf_7d < MIN_SHADOW_PF_7D:
        reasons.append(f"shadow_pf_7d={pf_7d or 0:.3f}<{MIN_SHADOW_PF_7D}")
        return False, reasons
    
    if pf_30d is None or pf_30d < MIN_SHADOW_PF_30D:
        reasons.append(f"shadow_pf_30d={pf_30d or 0:.3f}<{MIN_SHADOW_PF_30D}")
        return False, reasons
    
    # 5. Sample minimums (already checked in hard disarms, but verify)
    trades_7d = global_metrics.get("trades_7d", 0)
    trades_30d = global_metrics.get("trades_30d", 0)
    
    if trades_7d < MIN_SHADOW_TRADES_7D:
        reasons.append(f"shadow_trades_7d={trades_7d}<{MIN_SHADOW_TRADES_7D}")
        return False, reasons
    
    if trades_30d < MIN_SHADOW_TRADES_30D:
        reasons.append(f"shadow_trades_30d={trades_30d}<{MIN_SHADOW_TRADES_30D}")
        return False, reasons
    
    # 6. Execution quality (check for hostile)
    for symbol in eligible_symbols:
        symbol_exec = _get(execution_quality, "data", symbol, "summary", "overall_label") or \
                     _get(execution_quality, "symbols", symbol, "overall_label")
        if symbol_exec == "hostile":
            reasons.append(f"{symbol}_exec_quality=hostile")
            return False, reasons
    
    return True, []


def _compute_arm_score(
    shadow_scores: Dict[str, Any],
    execution_quality: Dict[str, Any],
    eligible_symbols: List[str],
    capital_plan: Dict[str, Any],
) -> float:
    """
    Compute arm score [0, 1] for diagnostic visibility.
    
    Weighted factors:
    - shadow_pf_7d_display (30%)
    - shadow_pf_30d_display (30%)
    - execution quality (20%)
    - capital weight concentration (10%)
    - sample sufficiency (10%)
    """
    score = 0.0
    
    global_metrics = shadow_scores.get("global", {})
    
    # PF scores (30% + 30%)
    pf_7d = global_metrics.get("pf_7d_display") or global_metrics.get("pf_7d") or 1.0
    pf_30d = global_metrics.get("pf_30d_display") or global_metrics.get("pf_30d") or 1.0
    
    pf7_score = min(1.0, (pf_7d - 1.0) / 0.5) if pf_7d else 0.0  # Normalize: 1.0 → 0, 1.5 → 1
    pf30_score = min(1.0, (pf_30d - 1.0) / 0.3) if pf_30d else 0.0  # Normalize: 1.0 → 0, 1.3 → 1
    
    score += 0.30 * max(0.0, pf7_score)
    score += 0.30 * max(0.0, pf30_score)
    
    # Execution quality (20%)
    exec_score = 1.0
    for symbol in eligible_symbols[:5]:  # Check top 5
        symbol_exec = _get(execution_quality, "data", symbol, "summary", "overall_label") or \
                     _get(execution_quality, "symbols", symbol, "overall_label")
        if symbol_exec == "hostile":
            exec_score = 0.0
            break
        elif symbol_exec == "degraded":
            exec_score = min(exec_score, 0.5)
    score += 0.20 * exec_score
    
    # Capital weight concentration (10%)
    by_symbol = capital_plan.get("by_symbol", {}) or capital_plan.get("symbols", {})
    total_weight = sum(
        (d.get("weight", 0.0) or d.get("capital_weight", 0.0))
        for d in by_symbol.values()
        if d.get("lane_intent") == "exploit"
    )
    weight_score = min(1.0, total_weight / 0.5)  # Normalize: 0.5 total weight → 1.0
    score += 0.10 * weight_score
    
    # Sample sufficiency (10%)
    trades_7d = global_metrics.get("trades_7d", 0)
    trades_30d = global_metrics.get("trades_30d", 0)
    sample_score = min(1.0, trades_7d / MIN_SHADOW_TRADES_7D) * 0.5 + \
                   min(1.0, trades_30d / MIN_SHADOW_TRADES_30D) * 0.5
    score += 0.10 * sample_score
    
    return min(1.0, max(0.0, score))


def _get_eligible_exploit_symbols(
    capital_plan: Dict[str, Any],
    live_candidates: Dict[str, Any],
    policy: Dict[str, Any],
) -> List[str]:
    """Get list of symbols that pass exploit gate (read-only diagnostic)."""
    eligible = []
    
    by_symbol = capital_plan.get("by_symbol", {}) or capital_plan.get("symbols", {})
    live_by_symbol = live_candidates.get("by_symbol", {}) or live_candidates.get("symbols", {})
    policy_symbols = policy.get("symbols", {})
    
    for symbol, plan_data in by_symbol.items():
        lane_intent = plan_data.get("lane_intent", "")
        if lane_intent != "exploit":
            continue
        
        weight = plan_data.get("weight", 0.0) or plan_data.get("capital_weight", 0.0)
        if weight < MIN_CAPITAL_WEIGHT:
            continue
        
        live_data = live_by_symbol.get(symbol, {})
        ready_now = _is_ready_now(live_data.get("ready_now", False))
        if not ready_now:
            continue
        
        policy_data = policy_symbols.get(symbol, {})
        policy_level = policy_data.get("level", "")
        if policy_level == "blocked":
            continue
        
        eligible.append(symbol)
    
    return eligible


def compute_exploit_arming() -> Dict[str, Any]:
    """
    Compute exploit arming state.
    
    Returns:
        Dict with arming state (matches exploit_arming.json schema)
    """
    ts = datetime.now(timezone.utc).isoformat()
    
    # Load all inputs (fault-tolerant)
    capital_protection = _load_json(CAPITAL_PROTECTION_PATH)
    capital_plan = _load_json(CAPITAL_PLAN_PATH)
    live_candidates = _load_json(LIVE_CANDIDATES_PATH)
    shadow_scores = _load_json(SHADOW_SCORES_PATH)
    execution_quality = _load_json(EXECUTION_QUALITY_PATH)
    policy = _load_json(POLICY_PATH)
    
    # Load previous state for hysteresis tracking
    prev_state = _load_json(ARMING_STATE_PATH)
    consecutive_ok_ticks = prev_state.get("consecutive_ok_ticks", 0)
    armed_since = prev_state.get("armed_since")
    
    # Extract capital mode
    capital_mode = capital_protection.get("mode") or \
                   _get(capital_protection, "global", "mode") or "unknown"
    
    # Check operator flag
    operator_enabled = os.getenv("ENABLE_MICRO_PAPER_EXPLOIT", "false").lower() == "true"
    
    # Get eligible exploit symbols (read-only diagnostic)
    eligible_symbols = _get_eligible_exploit_symbols(capital_plan, live_candidates, policy)
    
    # Check hard safety disarms (instant, no hysteresis)
    should_disarm, disarm_reason = _check_hard_safety_disarms(
        capital_mode=capital_mode,
        operator_enabled=operator_enabled,
        eligible_count=len(eligible_symbols),
        shadow_scores=shadow_scores,
        exploit_symbols=eligible_symbols,
    )
    
    # Phase: Promotion Gate - check if exploit opens are allowed
    promotion_gate = _load_json(PROMOTION_GATE_PATH)
    promotion_mode = promotion_gate.get("mode", "DISABLED")
    
    if promotion_mode != "EXPLOIT_ENABLED":
        # Force disarm if promotion gate not enabled
        return {
            "ts": ts,
            "operator_enabled": operator_enabled,
            "capital_mode": capital_mode,
            "armed": False,
            "arm_score": 0.0,
            "armed_since": None,
            "disarm_reason": f"promotion_gate_mode={promotion_mode}",
            "arming_reasons": [],
            "eligible_symbols": eligible_symbols,
            "consecutive_ok_ticks": 0,
        }
    
    if should_disarm:
        # Phase 5f: During de_risk, allow score accumulation but never arm
        if capital_mode == "de_risk":
            # Compute arm score for visibility (recovery signal)
            arm_score = _compute_arm_score(
                shadow_scores=shadow_scores,
                execution_quality=execution_quality,
                eligible_symbols=eligible_symbols,
                capital_plan=capital_plan,
            )
            
            # Load previous state to preserve consecutive_ok_ticks if conditions improving
            prev_consecutive = prev_state.get("consecutive_ok_ticks", 0)
            
            # Check if conditions are improving (for recovery signal)
            all_conditions_met, arming_reasons = _check_arming_conditions(
                capital_mode=capital_mode,
                operator_enabled=operator_enabled,
                eligible_symbols=eligible_symbols,
                shadow_scores=shadow_scores,
                execution_quality=execution_quality,
            )
            
            if all_conditions_met:
                # Conditions met but capital_mode blocks arming - accumulate ticks for recovery
                consecutive_ok_ticks = prev_consecutive + 1
            else:
                consecutive_ok_ticks = 0
            
            return {
                "ts": ts,
                "operator_enabled": operator_enabled,
                "capital_mode": capital_mode,
                "armed": False,  # Never arm during de_risk
                "arm_score": arm_score,
                "armed_since": None,
                "disarm_reason": f"capital_mode=de_risk (score_accumulating={consecutive_ok_ticks})",
                "arming_reasons": arming_reasons if all_conditions_met else [],
                "eligible_symbols": eligible_symbols,
                "consecutive_ok_ticks": consecutive_ok_ticks,
            }
        
        # Instant disarm for other reasons - reset counter
        return {
            "ts": ts,
            "operator_enabled": operator_enabled,
            "capital_mode": capital_mode,
            "armed": False,
            "arm_score": 0.0,
            "armed_since": None,
            "disarm_reason": disarm_reason,
            "arming_reasons": [],
            "eligible_symbols": eligible_symbols,
            "consecutive_ok_ticks": 0,
        }
    
    # Check arming conditions (with hysteresis)
    all_conditions_met, arming_reasons = _check_arming_conditions(
        capital_mode=capital_mode,
        operator_enabled=operator_enabled,
        eligible_symbols=eligible_symbols,
        shadow_scores=shadow_scores,
        execution_quality=execution_quality,
    )
    
    if all_conditions_met:
        # Increment counter
        consecutive_ok_ticks += 1
        
        # Arm if counter reaches threshold
        if consecutive_ok_ticks >= REQUIRED_CONSECUTIVE_OK_TICKS:
            if not armed_since:
                armed_since = ts  # First time arming
            
            # Compute arm score
            arm_score = _compute_arm_score(
                shadow_scores=shadow_scores,
                execution_quality=execution_quality,
                eligible_symbols=eligible_symbols,
                capital_plan=capital_plan,
            )
            
            return {
                "ts": ts,
                "operator_enabled": operator_enabled,
                "capital_mode": capital_mode,
                "armed": True,
                "arm_score": arm_score,
                "armed_since": armed_since,
                "disarm_reason": None,
                "arming_reasons": ["all_conditions_met"],
                "eligible_symbols": eligible_symbols,
                "consecutive_ok_ticks": consecutive_ok_ticks,
            }
        else:
            # Conditions met but not enough ticks yet
            arm_score = _compute_arm_score(
                shadow_scores=shadow_scores,
                execution_quality=execution_quality,
                eligible_symbols=eligible_symbols,
                capital_plan=capital_plan,
            )
            
            return {
                "ts": ts,
                "operator_enabled": operator_enabled,
                "capital_mode": capital_mode,
                "armed": False,
                "arm_score": arm_score,
                "armed_since": None,
                "disarm_reason": f"hysteresis: {consecutive_ok_ticks}/{REQUIRED_CONSECUTIVE_OK_TICKS}",
                "arming_reasons": ["conditions_met_waiting_ticks"],
                "eligible_symbols": eligible_symbols,
                "consecutive_ok_ticks": consecutive_ok_ticks,
            }
    else:
        # Conditions not met - reset counter
        arm_score = _compute_arm_score(
            shadow_scores=shadow_scores,
            execution_quality=execution_quality,
            eligible_symbols=eligible_symbols,
            capital_plan=capital_plan,
        )
        
        return {
            "ts": ts,
            "operator_enabled": operator_enabled,
            "capital_mode": capital_mode,
            "armed": False,
            "arm_score": arm_score,
            "armed_since": None,
            "disarm_reason": "; ".join(arming_reasons) if arming_reasons else "conditions_not_met",
            "arming_reasons": [],
            "eligible_symbols": eligible_symbols,
            "consecutive_ok_ticks": 0,
        }


def run_exploit_arming() -> Dict[str, Any]:
    """
    Run exploit arming engine and write state file.
    
    Returns:
        Arming state dict
    """
    try:
        state = compute_exploit_arming()
        
        # Write state file
        ARMING_STATE_PATH.parent.mkdir(parents=True, exist_ok=True)
        with ARMING_STATE_PATH.open("w", encoding="utf-8") as f:
            json.dump(state, f, indent=2)
        
        return state
    except Exception as e:
        # Fail-safe: return disarmed state
        ts = datetime.now(timezone.utc).isoformat()
        operator_enabled = os.getenv("ENABLE_MICRO_PAPER_EXPLOIT", "false").lower() == "true"
        
        fail_safe_state = {
            "ts": ts,
            "operator_enabled": operator_enabled,
            "capital_mode": "unknown",
            "armed": False,
            "arm_score": 0.0,
            "armed_since": None,
            "disarm_reason": f"exception: {str(e)}",
            "arming_reasons": [],
            "eligible_symbols": [],
            "consecutive_ok_ticks": 0,
        }
        
        try:
            ARMING_STATE_PATH.parent.mkdir(parents=True, exist_ok=True)
            with ARMING_STATE_PATH.open("w", encoding="utf-8") as f:
                json.dump(fail_safe_state, f, indent=2)
        except Exception:
            pass
        
        return fail_safe_state

